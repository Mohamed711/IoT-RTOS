
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c2e  00007000  00007000  00000074  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .trampolines  00000000  00007c2e  00007c2e  00000ca2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000008b  00800060  00007c2e  00000ca2  2**0
                  ALLOC
  3 .stab         00002160  00000000  00000000  00000ca4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000f3d  00000000  00000000  00002e04  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__ctors_end>:
    7000:	11 24       	eor	r1, r1
    7002:	1f be       	out	0x3f, r1	; 63
    7004:	cf e5       	ldi	r28, 0x5F	; 95
    7006:	d8 e0       	ldi	r29, 0x08	; 8
    7008:	de bf       	out	0x3e, r29	; 62
    700a:	cd bf       	out	0x3d, r28	; 61

0000700c <__do_clear_bss>:
    700c:	10 e0       	ldi	r17, 0x00	; 0
    700e:	a0 e6       	ldi	r26, 0x60	; 96
    7010:	b0 e0       	ldi	r27, 0x00	; 0
    7012:	01 c0       	rjmp	.+2      	; 0x7016 <.do_clear_bss_start>

00007014 <.do_clear_bss_loop>:
    7014:	1d 92       	st	X+, r1

00007016 <.do_clear_bss_start>:
    7016:	ab 3e       	cpi	r26, 0xEB	; 235
    7018:	b1 07       	cpc	r27, r17
    701a:	e1 f7       	brne	.-8      	; 0x7014 <.do_clear_bss_loop>
    701c:	0e 94 41 39 	call	0x7282	; 0x7282 <main>
    7020:	0c 94 15 3e 	jmp	0x7c2a	; 0x7c2a <_exit>

00007024 <__bad_interrupt>:
    7024:	0c 94 14 38 	jmp	0x7028	; 0x7028 <__vector_default>

00007028 <__vector_default>:

#if defined(BOOTLOADERHASNOVECTORS)
#warning "This Bootloader does not link interrupt vectors - see makefile"
/* make the linker happy - it wants to see __vector_default */
// void __vector_default(void) { ; }
void __vector_default(void) { ; }
    7028:	08 95       	ret

0000702a <bootLoader_ReceiveBuffer>:
	}
	boot_rww_enable();
}

static inline void bootLoader_ReceiveBuffer(pagebuf_t size)
{
    702a:	cf 92       	push	r12
    702c:	df 92       	push	r13
    702e:	ef 92       	push	r14
    7030:	ff 92       	push	r15
    7032:	0f 93       	push	r16
    7034:	1f 93       	push	r17
    7036:	df 93       	push	r29
    7038:	cf 93       	push	r28
    703a:	00 d0       	rcall	.+0      	; 0x703c <bootLoader_ReceiveBuffer+0x12>
    703c:	cd b7       	in	r28, 0x3d	; 61
    703e:	de b7       	in	r29, 0x3e	; 62
    7040:	08 2f       	mov	r16, r24
    7042:	10 e0       	ldi	r17, 0x00	; 0
    7044:	80 e6       	ldi	r24, 0x60	; 96
    7046:	e8 2e       	mov	r14, r24
    7048:	80 e0       	ldi	r24, 0x00	; 0
    704a:	f8 2e       	mov	r15, r24
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    704c:	6e 01       	movw	r12, r28
    704e:	08 94       	sec
    7050:	c1 1c       	adc	r12, r1
    7052:	d1 1c       	adc	r13, r1
{
	pagebuf_t cnt;
	uint8_t *tmp = gBuffer;

	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) {
		*tmp++ = (cnt < size) ? bootLoader_ReceiveChar() : 0xFF;
    7054:	10 17       	cp	r17, r16
    7056:	10 f0       	brcs	.+4      	; 0x705c <bootLoader_ReceiveBuffer+0x32>
    7058:	8f ef       	ldi	r24, 0xFF	; 255
    705a:	04 c0       	rjmp	.+8      	; 0x7064 <bootLoader_ReceiveBuffer+0x3a>
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    705c:	c6 01       	movw	r24, r12
    705e:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
	return x;
    7062:	89 81       	ldd	r24, Y+1	; 0x01
{
	pagebuf_t cnt;
	uint8_t *tmp = gBuffer;

	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) {
		*tmp++ = (cnt < size) ? bootLoader_ReceiveChar() : 0xFF;
    7064:	f7 01       	movw	r30, r14
    7066:	81 93       	st	Z+, r24
    7068:	7f 01       	movw	r14, r30
static inline void bootLoader_ReceiveBuffer(pagebuf_t size)
{
	pagebuf_t cnt;
	uint8_t *tmp = gBuffer;

	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) {
    706a:	1f 5f       	subi	r17, 0xFF	; 255
    706c:	10 38       	cpi	r17, 0x80	; 128
    706e:	91 f7       	brne	.-28     	; 0x7054 <bootLoader_ReceiveBuffer+0x2a>
		*tmp++ = (cnt < size) ? bootLoader_ReceiveChar() : 0xFF;
	}
}
    7070:	0f 90       	pop	r0
    7072:	0f 90       	pop	r0
    7074:	cf 91       	pop	r28
    7076:	df 91       	pop	r29
    7078:	1f 91       	pop	r17
    707a:	0f 91       	pop	r16
    707c:	ff 90       	pop	r15
    707e:	ef 90       	pop	r14
    7080:	df 90       	pop	r13
    7082:	cf 90       	pop	r12
    7084:	08 95       	ret

00007086 <bootLoader_SendEcho>:
	return bootLoader_WriteFlashPage(fAddress, size);
	
}	

static void bootLoader_SendEcho(void)
{
    7086:	ff 92       	push	r15
    7088:	0f 93       	push	r16
    708a:	1f 93       	push	r17
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    708c:	81 e4       	ldi	r24, 0x41	; 65
    708e:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    7092:	00 ee       	ldi	r16, 0xE0	; 224
    7094:	10 e0       	ldi	r17, 0x00	; 0
    7096:	c8 01       	movw	r24, r16
    7098:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    709c:	86 e5       	ldi	r24, 0x56	; 86
    709e:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    70a2:	c8 01       	movw	r24, r16
    70a4:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    70a8:	82 e5       	ldi	r24, 0x52	; 82
    70aa:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    70ae:	c8 01       	movw	r24, r16
    70b0:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    70b4:	82 e4       	ldi	r24, 0x42	; 66
    70b6:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    70ba:	c8 01       	movw	r24, r16
    70bc:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    70c0:	9f e4       	ldi	r25, 0x4F	; 79
    70c2:	f9 2e       	mov	r15, r25
    70c4:	f0 92 e0 00 	sts	0x00E0, r15
	HAL_comm_UART_Send(&uart_handle);
    70c8:	c8 01       	movw	r24, r16
    70ca:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    70ce:	f0 92 e0 00 	sts	0x00E0, r15
	HAL_comm_UART_Send(&uart_handle);
    70d2:	c8 01       	movw	r24, r16
    70d4:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    70d8:	84 e5       	ldi	r24, 0x54	; 84
    70da:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    70de:	c8 01       	movw	r24, r16
    70e0:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
	bootLoader_SendChar('R');
	bootLoader_SendChar('B');
	bootLoader_SendChar('O');
	bootLoader_SendChar('O');
	bootLoader_SendChar('T');
}
    70e4:	1f 91       	pop	r17
    70e6:	0f 91       	pop	r16
    70e8:	ff 90       	pop	r15
    70ea:	08 95       	ret

000070ec <bootLoader_WriteFlashPage>:
		*tmp++ = (cnt < size) ? bootLoader_ReceiveChar() : 0xFF;
	}
}

static inline uint16_t bootLoader_WriteFlashPage(uint16_t waddr, pagebuf_t size)
{
    70ec:	af 92       	push	r10
    70ee:	bf 92       	push	r11
    70f0:	cf 92       	push	r12
    70f2:	df 92       	push	r13
    70f4:	ef 92       	push	r14
    70f6:	ff 92       	push	r15
    70f8:	0f 93       	push	r16
    70fa:	1f 93       	push	r17
    70fc:	cf 93       	push	r28
    70fe:	df 93       	push	r29
    7100:	a6 2f       	mov	r26, r22
	uint32_t pagestart = (uint32_t)waddr<<1;
    7102:	ac 01       	movw	r20, r24
    7104:	60 e0       	ldi	r22, 0x00	; 0
    7106:	70 e0       	ldi	r23, 0x00	; 0
    7108:	44 0f       	add	r20, r20
    710a:	55 1f       	adc	r21, r21
    710c:	66 1f       	adc	r22, r22
    710e:	77 1f       	adc	r23, r23
    7110:	7a 01       	movw	r14, r20
    7112:	8b 01       	movw	r16, r22
    7114:	c0 e6       	ldi	r28, 0x60	; 96
    7116:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t *tmp = gBuffer;
	
	do {
		data = *tmp++;
		data |= *tmp++ << 8;
		boot_page_fill(baddr, data);	// call asm routine.
    7118:	b1 e0       	ldi	r27, 0x01	; 1
	uint32_t baddr = pagestart;
	uint16_t data;
	uint8_t *tmp = gBuffer;
	
	do {
		data = *tmp++;
    711a:	88 81       	ld	r24, Y
    711c:	90 e0       	ldi	r25, 0x00	; 0
		data |= *tmp++ << 8;
    711e:	39 81       	ldd	r19, Y+1	; 0x01
    7120:	20 e0       	ldi	r18, 0x00	; 0
    7122:	82 2b       	or	r24, r18
    7124:	93 2b       	or	r25, r19
		*tmp++ = (cnt < size) ? bootLoader_ReceiveChar() : 0xFF;
	}
}

static inline uint16_t bootLoader_WriteFlashPage(uint16_t waddr, pagebuf_t size)
{
    7126:	22 96       	adiw	r28, 0x02	; 2
	uint8_t *tmp = gBuffer;
	
	do {
		data = *tmp++;
		data |= *tmp++ << 8;
		boot_page_fill(baddr, data);	// call asm routine.
    7128:	f7 01       	movw	r30, r14
    712a:	0c 01       	movw	r0, r24
    712c:	b0 93 57 00 	sts	0x0057, r27
    7130:	e8 95       	spm
    7132:	11 24       	eor	r1, r1
		
		baddr += 2;			// Select next word in memory
    7134:	72 e0       	ldi	r23, 0x02	; 2
    7136:	a7 2e       	mov	r10, r23
    7138:	b1 2c       	mov	r11, r1
    713a:	c1 2c       	mov	r12, r1
    713c:	d1 2c       	mov	r13, r1
    713e:	ea 0c       	add	r14, r10
    7140:	fb 1c       	adc	r15, r11
    7142:	0c 1d       	adc	r16, r12
    7144:	1d 1d       	adc	r17, r13
		size -= 2;			// Reduce number of bytes to write by two
    7146:	a2 50       	subi	r26, 0x02	; 2
	
	} while (size);				// Loop until all bytes written
    7148:	41 f7       	brne	.-48     	; 0x711a <bootLoader_WriteFlashPage+0x2e>

	boot_page_write(pagestart);
    714a:	85 e0       	ldi	r24, 0x05	; 5
    714c:	fa 01       	movw	r30, r20
    714e:	80 93 57 00 	sts	0x0057, r24
    7152:	e8 95       	spm
	boot_spm_busy_wait();
    7154:	07 b6       	in	r0, 0x37	; 55
    7156:	00 fc       	sbrc	r0, 0
    7158:	fd cf       	rjmp	.-6      	; 0x7154 <bootLoader_WriteFlashPage+0x68>
	boot_rww_enable();		// Re-enable the RWW section
    715a:	81 e1       	ldi	r24, 0x11	; 17
    715c:	80 93 57 00 	sts	0x0057, r24
    7160:	e8 95       	spm
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7162:	86 e4       	ldi	r24, 0x46	; 70
    7164:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    7168:	80 ee       	ldi	r24, 0xE0	; 224
    716a:	90 e0       	ldi	r25, 0x00	; 0
    716c:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7170:	87 e7       	ldi	r24, 0x77	; 119
    7172:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    7176:	80 ee       	ldi	r24, 0xE0	; 224
    7178:	90 e0       	ldi	r25, 0x00	; 0
    717a:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    717e:	82 e7       	ldi	r24, 0x72	; 114
    7180:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    7184:	80 ee       	ldi	r24, 0xE0	; 224
    7186:	90 e0       	ldi	r25, 0x00	; 0
    7188:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    718c:	89 e6       	ldi	r24, 0x69	; 105
    718e:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    7192:	80 ee       	ldi	r24, 0xE0	; 224
    7194:	90 e0       	ldi	r25, 0x00	; 0
    7196:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    719a:	84 e7       	ldi	r24, 0x74	; 116
    719c:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    71a0:	80 ee       	ldi	r24, 0xE0	; 224
    71a2:	90 e0       	ldi	r25, 0x00	; 0
    71a4:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    71a8:	85 e6       	ldi	r24, 0x65	; 101
    71aa:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    71ae:	80 ee       	ldi	r24, 0xE0	; 224
    71b0:	90 e0       	ldi	r25, 0x00	; 0
    71b2:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
    71b6:	a8 01       	movw	r20, r16
    71b8:	97 01       	movw	r18, r14
    71ba:	56 95       	lsr	r21
    71bc:	47 95       	ror	r20
    71be:	37 95       	ror	r19
    71c0:	27 95       	ror	r18
	bootLoader_SendChar('i');
	bootLoader_SendChar('t');
	bootLoader_SendChar('e');
	
	return baddr>>1;
}
    71c2:	c9 01       	movw	r24, r18
    71c4:	df 91       	pop	r29
    71c6:	cf 91       	pop	r28
    71c8:	1f 91       	pop	r17
    71ca:	0f 91       	pop	r16
    71cc:	ff 90       	pop	r15
    71ce:	ef 90       	pop	r14
    71d0:	df 90       	pop	r13
    71d2:	cf 90       	pop	r12
    71d4:	bf 90       	pop	r11
    71d6:	af 90       	pop	r10
    71d8:	08 95       	ret

000071da <bootLoader_WriteEEPROM>:

static inline uint16_t bootLoader_WriteEEPROM(uint16_t address, pagebuf_t size)
{
    71da:	cf 92       	push	r12
    71dc:	df 92       	push	r13
    71de:	ef 92       	push	r14
    71e0:	ff 92       	push	r15
    71e2:	0f 93       	push	r16
    71e4:	1f 93       	push	r17
    71e6:	cf 93       	push	r28
    71e8:	df 93       	push	r29
    71ea:	6c 01       	movw	r12, r24
    71ec:	06 2f       	mov	r16, r22
    71ee:	ec 01       	movw	r28, r24
    71f0:	16 2f       	mov	r17, r22
    71f2:	f0 e6       	ldi	r31, 0x60	; 96
    71f4:	ef 2e       	mov	r14, r31
    71f6:	f0 e0       	ldi	r31, 0x00	; 0
    71f8:	ff 2e       	mov	r15, r31
	uint8_t *tmp = gBuffer;

	do {
		eeprom_write_byte( (uint8_t*)address, *tmp++ );
    71fa:	f7 01       	movw	r30, r14
    71fc:	61 91       	ld	r22, Z+
    71fe:	7f 01       	movw	r14, r30
    7200:	ce 01       	movw	r24, r28
    7202:	0e 94 08 3e 	call	0x7c10	; 0x7c10 <__eewr_byte_m32>
		address++;			// Select next byte
    7206:	21 96       	adiw	r28, 0x01	; 1
		size--;				// Decreas number of bytes to write
    7208:	11 50       	subi	r17, 0x01	; 1
	} while (size);				// Loop until all bytes written
    720a:	b9 f7       	brne	.-18     	; 0x71fa <bootLoader_WriteEEPROM+0x20>
	
	return baddr>>1;
}

static inline uint16_t bootLoader_WriteEEPROM(uint16_t address, pagebuf_t size)
{
    720c:	08 94       	sec
    720e:	c1 1c       	adc	r12, r1
    7210:	d1 1c       	adc	r13, r1
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7212:	85 e4       	ldi	r24, 0x45	; 69
    7214:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    7218:	80 ee       	ldi	r24, 0xE0	; 224
    721a:	90 e0       	ldi	r25, 0x00	; 0
    721c:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7220:	87 e7       	ldi	r24, 0x77	; 119
    7222:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    7226:	80 ee       	ldi	r24, 0xE0	; 224
    7228:	90 e0       	ldi	r25, 0x00	; 0
    722a:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    722e:	82 e7       	ldi	r24, 0x72	; 114
    7230:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    7234:	80 ee       	ldi	r24, 0xE0	; 224
    7236:	90 e0       	ldi	r25, 0x00	; 0
    7238:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    723c:	89 e6       	ldi	r24, 0x69	; 105
    723e:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    7242:	80 ee       	ldi	r24, 0xE0	; 224
    7244:	90 e0       	ldi	r25, 0x00	; 0
    7246:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    724a:	84 e7       	ldi	r24, 0x74	; 116
    724c:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    7250:	80 ee       	ldi	r24, 0xE0	; 224
    7252:	90 e0       	ldi	r25, 0x00	; 0
    7254:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7258:	85 e6       	ldi	r24, 0x65	; 101
    725a:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    725e:	80 ee       	ldi	r24, 0xE0	; 224
    7260:	90 e0       	ldi	r25, 0x00	; 0
    7262:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
    7266:	01 50       	subi	r16, 0x01	; 1
    7268:	96 01       	movw	r18, r12
    726a:	20 0f       	add	r18, r16
    726c:	31 1d       	adc	r19, r1
		bootLoader_SendChar('t');
		bootLoader_SendChar('e');
		

	return address;
}
    726e:	c9 01       	movw	r24, r18
    7270:	df 91       	pop	r29
    7272:	cf 91       	pop	r28
    7274:	1f 91       	pop	r17
    7276:	0f 91       	pop	r16
    7278:	ff 90       	pop	r15
    727a:	ef 90       	pop	r14
    727c:	df 90       	pop	r13
    727e:	cf 90       	pop	r12
    7280:	08 95       	ret

00007282 <main>:
}

static void (*jump_to_app1)(void) = 0x0000;

int main(void)
{
    7282:	2f 92       	push	r2
    7284:	3f 92       	push	r3
    7286:	4f 92       	push	r4
    7288:	5f 92       	push	r5
    728a:	6f 92       	push	r6
    728c:	7f 92       	push	r7
    728e:	8f 92       	push	r8
    7290:	9f 92       	push	r9
    7292:	af 92       	push	r10
    7294:	bf 92       	push	r11
    7296:	cf 92       	push	r12
    7298:	df 92       	push	r13
    729a:	ef 92       	push	r14
    729c:	ff 92       	push	r15
    729e:	0f 93       	push	r16
    72a0:	1f 93       	push	r17
    72a2:	df 93       	push	r29
    72a4:	cf 93       	push	r28
    72a6:	cd b7       	in	r28, 0x3d	; 61
    72a8:	de b7       	in	r29, 0x3e	; 62
    72aa:	62 97       	sbiw	r28, 0x12	; 18
    72ac:	0f b6       	in	r0, 0x3f	; 63
    72ae:	f8 94       	cli
    72b0:	de bf       	out	0x3e, r29	; 62
    72b2:	0f be       	out	0x3f, r0	; 63
    72b4:	cd bf       	out	0x3d, r28	; 61
	uint16_t addressEW = 0;
	uint8_t val;

#ifdef DISABLE_WDT_AT_STARTUP

	cli();
    72b6:	f8 94       	cli
	wdt_reset();
    72b8:	a8 95       	wdr
	wdt_disable();
    72ba:	88 e1       	ldi	r24, 0x18	; 24
    72bc:	0f b6       	in	r0, 0x3f	; 63
    72be:	f8 94       	cli
    72c0:	81 bd       	out	0x21, r24	; 33
    72c2:	11 bc       	out	0x21, r1	; 33
    72c4:	0f be       	out	0x3f, r0	; 63

#endif

	uart_init_config.Baud = 19200;
    72c6:	80 e0       	ldi	r24, 0x00	; 0
    72c8:	9b e4       	ldi	r25, 0x4B	; 75
    72ca:	a0 e0       	ldi	r26, 0x00	; 0
    72cc:	b0 e0       	ldi	r27, 0x00	; 0
    72ce:	80 93 e1 00 	sts	0x00E1, r24
    72d2:	90 93 e2 00 	sts	0x00E2, r25
    72d6:	a0 93 e3 00 	sts	0x00E3, r26
    72da:	b0 93 e4 00 	sts	0x00E4, r27
	uart_init_config.DataBits = DATA_BIT_8;
    72de:	86 e0       	ldi	r24, 0x06	; 6
    72e0:	80 93 e5 00 	sts	0x00E5, r24
	uart_init_config.StopBits = STOP_BIT_1;
    72e4:	10 92 e6 00 	sts	0x00E6, r1
	uart_init_config.Parity = PARITY_DISABLE;
    72e8:	10 92 e7 00 	sts	0x00E7, r1
	uart_init_config.EnableInterrupt = 0;
    72ec:	10 92 e8 00 	sts	0x00E8, r1
	uart_init_config.U2X_State = U2X_DISABLE;
    72f0:	10 92 e9 00 	sts	0x00E9, r1
	
	HAL_comm_UART_Initialize(&uart_init_config);
    72f4:	81 ee       	ldi	r24, 0xE1	; 225
    72f6:	90 e0       	ldi	r25, 0x00	; 0
    72f8:	0e 94 1c 3d 	call	0x7a38	; 0x7a38 <HAL_comm_UART_Initialize>

		
	uint16_t cnt = 0;

	bootLoader_SendEcho();
    72fc:	0e 94 43 38 	call	0x7086	; 0x7086 <bootLoader_SendEcho>
    7300:	00 e0       	ldi	r16, 0x00	; 0
    7302:	10 e0       	ldi	r17, 0x00	; 0
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7304:	6f e5       	ldi	r22, 0x5F	; 95
    7306:	f6 2e       	mov	r15, r22
    7308:	51 e3       	ldi	r21, 0x31	; 49
    730a:	85 2e       	mov	r8, r21
    730c:	43 e3       	ldi	r20, 0x33	; 51
    730e:	94 2e       	mov	r9, r20
		if (cnt++ >= WAIT_VALUE) {
			
			bootLoader_SendChar('_');
			bootLoader_SendChar('3');
			bootLoader_SendChar('_');
			jump_to_app1();			// Jump to application sector
    7310:	aa 24       	eor	r10, r10
    7312:	bb 24       	eor	r11, r11
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7314:	33 e2       	ldi	r19, 0x23	; 35
    7316:	e3 2e       	mov	r14, r19
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7318:	24 ec       	ldi	r18, 0xC4	; 196
    731a:	c2 2e       	mov	r12, r18
    731c:	29 e0       	ldi	r18, 0x09	; 9
    731e:	d2 2e       	mov	r13, r18

	bootLoader_SendEcho();
	
	while (1) {
		
		if (UART_STATUS & (1<<UART_RXREADY))
    7320:	5f 9b       	sbis	0x0b, 7	; 11
    7322:	31 c0       	rjmp	.+98     	; 0x7386 <main+0x104>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7324:	f0 92 e0 00 	sts	0x00E0, r15
	HAL_comm_UART_Send(&uart_handle);
    7328:	80 ee       	ldi	r24, 0xE0	; 224
    732a:	90 e0       	ldi	r25, 0x00	; 0
    732c:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7330:	80 92 e0 00 	sts	0x00E0, r8
	HAL_comm_UART_Send(&uart_handle);
    7334:	80 ee       	ldi	r24, 0xE0	; 224
    7336:	90 e0       	ldi	r25, 0x00	; 0
    7338:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    733c:	f0 92 e0 00 	sts	0x00E0, r15
	HAL_comm_UART_Send(&uart_handle);
    7340:	80 ee       	ldi	r24, 0xE0	; 224
    7342:	90 e0       	ldi	r25, 0x00	; 0
    7344:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
		if (UART_STATUS & (1<<UART_RXREADY))
		{
			bootLoader_SendChar('_');
			bootLoader_SendChar('1');
			bootLoader_SendChar('_');
			if (UART_DATA == START_WAIT_UARTCHAR)
    7348:	8c b1       	in	r24, 0x0c	; 12
    734a:	83 35       	cpi	r24, 0x53	; 83
    734c:	e1 f4       	brne	.+56     	; 0x7386 <main+0x104>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    734e:	f0 92 e0 00 	sts	0x00E0, r15
	HAL_comm_UART_Send(&uart_handle);
    7352:	80 ee       	ldi	r24, 0xE0	; 224
    7354:	90 e0       	ldi	r25, 0x00	; 0
    7356:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    735a:	82 e3       	ldi	r24, 0x32	; 50
    735c:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    7360:	80 ee       	ldi	r24, 0xE0	; 224
    7362:	90 e0       	ldi	r25, 0x00	; 0
    7364:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7368:	f0 92 e0 00 	sts	0x00E0, r15
	HAL_comm_UART_Send(&uart_handle);
    736c:	80 ee       	ldi	r24, 0xE0	; 224
    736e:	90 e0       	ldi	r25, 0x00	; 0
    7370:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
		}

		_delay_ms(10);
	}
	
	bootLoader_SendEcho();
    7374:	0e 94 43 38 	call	0x7086	; 0x7086 <bootLoader_SendEcho>
    7378:	1a 86       	std	Y+10, r1	; 0x0a
    737a:	19 86       	std	Y+9, r1	; 0x09
    737c:	22 24       	eor	r2, r2
    737e:	33 24       	eor	r3, r3
    7380:	18 86       	std	Y+8, r1	; 0x08
    7382:	1f 82       	std	Y+7, r1	; 0x07
    7384:	fb c2       	rjmp	.+1526   	; 0x797c <main+0x6fa>
				bootLoader_SendChar('2');
				bootLoader_SendChar('_');
				break;
			}				
		}
		if (cnt++ >= WAIT_VALUE) {
    7386:	27 e2       	ldi	r18, 0x27	; 39
    7388:	00 31       	cpi	r16, 0x10	; 16
    738a:	12 07       	cpc	r17, r18
    738c:	d0 f0       	brcs	.+52     	; 0x73c2 <main+0x140>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    738e:	f0 92 e0 00 	sts	0x00E0, r15
	HAL_comm_UART_Send(&uart_handle);
    7392:	80 ee       	ldi	r24, 0xE0	; 224
    7394:	90 e0       	ldi	r25, 0x00	; 0
    7396:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    739a:	90 92 e0 00 	sts	0x00E0, r9
	HAL_comm_UART_Send(&uart_handle);
    739e:	80 ee       	ldi	r24, 0xE0	; 224
    73a0:	90 e0       	ldi	r25, 0x00	; 0
    73a2:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    73a6:	f0 92 e0 00 	sts	0x00E0, r15
	HAL_comm_UART_Send(&uart_handle);
    73aa:	80 ee       	ldi	r24, 0xE0	; 224
    73ac:	90 e0       	ldi	r25, 0x00	; 0
    73ae:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
		if (cnt++ >= WAIT_VALUE) {
			
			bootLoader_SendChar('_');
			bootLoader_SendChar('3');
			bootLoader_SendChar('_');
			jump_to_app1();			// Jump to application sector
    73b2:	f5 01       	movw	r30, r10
    73b4:	09 95       	icall
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    73b6:	e0 92 e0 00 	sts	0x00E0, r14
	HAL_comm_UART_Send(&uart_handle);
    73ba:	80 ee       	ldi	r24, 0xE0	; 224
    73bc:	90 e0       	ldi	r25, 0x00	; 0
    73be:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
				bootLoader_SendChar('2');
				bootLoader_SendChar('_');
				break;
			}				
		}
		if (cnt++ >= WAIT_VALUE) {
    73c2:	0f 5f       	subi	r16, 0xFF	; 255
    73c4:	1f 4f       	sbci	r17, 0xFF	; 255
    73c6:	c6 01       	movw	r24, r12
    73c8:	01 97       	sbiw	r24, 0x01	; 1
    73ca:	f1 f7       	brne	.-4      	; 0x73c8 <main+0x146>
    73cc:	a9 cf       	rjmp	.-174    	; 0x7320 <main+0x9e>
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    73ce:	ce 01       	movw	r24, r28
    73d0:	01 96       	adiw	r24, 0x01	; 1
    73d2:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
	return x;
    73d6:	f9 80       	ldd	r15, Y+1	; 0x01
	bootLoader_SendEcho();

	for(;;) {
		val = bootLoader_ReceiveChar();
		// Autoincrement?
		if (val == 'a') {
    73d8:	31 e6       	ldi	r19, 0x61	; 97
    73da:	f3 16       	cp	r15, r19
    73dc:	21 f4       	brne	.+8      	; 0x73e6 <main+0x164>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    73de:	89 e5       	ldi	r24, 0x59	; 89
    73e0:	80 93 e0 00 	sts	0x00E0, r24
    73e4:	fd c2       	rjmp	.+1530   	; 0x79e0 <main+0x75e>
		// Autoincrement?
		if (val == 'a') {
			bootLoader_SendChar('Y');			// Autoincrement is quicker

		//write addressW
		} else if (val == 'W') {
    73e6:	97 e5       	ldi	r25, 0x57	; 87
    73e8:	f9 16       	cp	r15, r25
    73ea:	a9 f5       	brne	.+106    	; 0x7456 <main+0x1d4>
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    73ec:	ce 01       	movw	r24, r28
    73ee:	01 96       	adiw	r24, 0x01	; 1
    73f0:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
	return x;
    73f4:	89 81       	ldd	r24, Y+1	; 0x01
			bootLoader_SendChar('Y');			// Autoincrement is quicker

		//write addressW
		} else if (val == 'W') {
			val = bootLoader_ReceiveChar();
			if(val == 'F')
    73f6:	86 34       	cpi	r24, 0x46	; 70
    73f8:	99 f4       	brne	.+38     	; 0x7420 <main+0x19e>
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    73fa:	ce 01       	movw	r24, r28
    73fc:	01 96       	adiw	r24, 0x01	; 1
    73fe:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
		} else if (val == 'W') {
			val = bootLoader_ReceiveChar();
			if(val == 'F')
			{
				addressFW = bootLoader_ReceiveChar();		//read address 8 MSB
				addressFW = (addressFW<<8) | bootLoader_ReceiveChar();
    7402:	a9 81       	ldd	r26, Y+1	; 0x01
    7404:	aa 8b       	std	Y+18, r26	; 0x12
    7406:	19 8a       	std	Y+17, r1	; 0x11
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    7408:	ce 01       	movw	r24, r28
    740a:	01 96       	adiw	r24, 0x01	; 1
    740c:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
		} else if (val == 'W') {
			val = bootLoader_ReceiveChar();
			if(val == 'F')
			{
				addressFW = bootLoader_ReceiveChar();		//read address 8 MSB
				addressFW = (addressFW<<8) | bootLoader_ReceiveChar();
    7410:	89 81       	ldd	r24, Y+1	; 0x01
    7412:	28 2e       	mov	r2, r24
    7414:	33 24       	eor	r3, r3
    7416:	e9 89       	ldd	r30, Y+17	; 0x11
    7418:	fa 89       	ldd	r31, Y+18	; 0x12
    741a:	2e 2a       	or	r2, r30
    741c:	3f 2a       	or	r3, r31
    741e:	17 c0       	rjmp	.+46     	; 0x744e <main+0x1cc>
				bootLoader_SendChar('\r');		
			}
			else if(val == 'E')
    7420:	85 34       	cpi	r24, 0x45	; 69
    7422:	09 f0       	breq	.+2      	; 0x7426 <main+0x1a4>
    7424:	ae c2       	rjmp	.+1372   	; 0x7982 <main+0x700>
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    7426:	ce 01       	movw	r24, r28
    7428:	01 96       	adiw	r24, 0x01	; 1
    742a:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
				bootLoader_SendChar('\r');		
			}
			else if(val == 'E')
			{
				addressEW = bootLoader_ReceiveChar();		//read address 8 MSB
				addressEW = (addressEW<<8) | bootLoader_ReceiveChar();
    742e:	29 81       	ldd	r18, Y+1	; 0x01
    7430:	28 8b       	std	Y+16, r18	; 0x10
    7432:	1f 86       	std	Y+15, r1	; 0x0f
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    7434:	ce 01       	movw	r24, r28
    7436:	01 96       	adiw	r24, 0x01	; 1
    7438:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
				bootLoader_SendChar('\r');		
			}
			else if(val == 'E')
			{
				addressEW = bootLoader_ReceiveChar();		//read address 8 MSB
				addressEW = (addressEW<<8) | bootLoader_ReceiveChar();
    743c:	89 81       	ldd	r24, Y+1	; 0x01
    743e:	a8 2f       	mov	r26, r24
    7440:	b0 e0       	ldi	r27, 0x00	; 0
    7442:	ef 85       	ldd	r30, Y+15	; 0x0f
    7444:	f8 89       	ldd	r31, Y+16	; 0x10
    7446:	ea 2b       	or	r30, r26
    7448:	fb 2b       	or	r31, r27
    744a:	fe 83       	std	Y+6, r31	; 0x06
    744c:	ed 83       	std	Y+5, r30	; 0x05
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    744e:	fd e0       	ldi	r31, 0x0D	; 13
    7450:	f0 93 e0 00 	sts	0x00E0, r31
    7454:	c5 c2       	rjmp	.+1418   	; 0x79e0 <main+0x75e>
			{
				bootLoader_SendChar(0);
			}
			
		//write addressR
		} else if (val == 'R'){
    7456:	22 e5       	ldi	r18, 0x52	; 82
    7458:	f2 16       	cp	r15, r18
    745a:	a1 f5       	brne	.+104    	; 0x74c4 <main+0x242>
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    745c:	ce 01       	movw	r24, r28
    745e:	01 96       	adiw	r24, 0x01	; 1
    7460:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
	return x;
    7464:	89 81       	ldd	r24, Y+1	; 0x01
			}
			
		//write addressR
		} else if (val == 'R'){
			val = bootLoader_ReceiveChar();
			if(val == 'F')
    7466:	86 34       	cpi	r24, 0x46	; 70
    7468:	a9 f4       	brne	.+42     	; 0x7494 <main+0x212>
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    746a:	ce 01       	movw	r24, r28
    746c:	01 96       	adiw	r24, 0x01	; 1
    746e:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
		} else if (val == 'R'){
			val = bootLoader_ReceiveChar();
			if(val == 'F')
			{
				addressFR = bootLoader_ReceiveChar();		//read address 8 MSB
				addressFR = (addressFR<<8) | bootLoader_ReceiveChar();
    7472:	39 81       	ldd	r19, Y+1	; 0x01
    7474:	3e 87       	std	Y+14, r19	; 0x0e
    7476:	1d 86       	std	Y+13, r1	; 0x0d
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    7478:	ce 01       	movw	r24, r28
    747a:	01 96       	adiw	r24, 0x01	; 1
    747c:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
		} else if (val == 'R'){
			val = bootLoader_ReceiveChar();
			if(val == 'F')
			{
				addressFR = bootLoader_ReceiveChar();		//read address 8 MSB
				addressFR = (addressFR<<8) | bootLoader_ReceiveChar();
    7480:	89 81       	ldd	r24, Y+1	; 0x01
    7482:	a8 2f       	mov	r26, r24
    7484:	b0 e0       	ldi	r27, 0x00	; 0
    7486:	ed 85       	ldd	r30, Y+13	; 0x0d
    7488:	fe 85       	ldd	r31, Y+14	; 0x0e
    748a:	ea 2b       	or	r30, r26
    748c:	fb 2b       	or	r31, r27
    748e:	fa 87       	std	Y+10, r31	; 0x0a
    7490:	e9 87       	std	Y+9, r30	; 0x09
    7492:	dd cf       	rjmp	.-70     	; 0x744e <main+0x1cc>
				bootLoader_SendChar('\r');
			}
			else if(val == 'E')
    7494:	85 34       	cpi	r24, 0x45	; 69
    7496:	09 f0       	breq	.+2      	; 0x749a <main+0x218>
    7498:	74 c2       	rjmp	.+1256   	; 0x7982 <main+0x700>
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    749a:	ce 01       	movw	r24, r28
    749c:	01 96       	adiw	r24, 0x01	; 1
    749e:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
				bootLoader_SendChar('\r');
			}
			else if(val == 'E')
			{
				addressER = bootLoader_ReceiveChar();		//read address 8 MSB
				addressER = (addressER<<8) | bootLoader_ReceiveChar();
    74a2:	29 81       	ldd	r18, Y+1	; 0x01
    74a4:	2c 87       	std	Y+12, r18	; 0x0c
    74a6:	1b 86       	std	Y+11, r1	; 0x0b
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    74a8:	ce 01       	movw	r24, r28
    74aa:	01 96       	adiw	r24, 0x01	; 1
    74ac:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
				bootLoader_SendChar('\r');
			}
			else if(val == 'E')
			{
				addressER = bootLoader_ReceiveChar();		//read address 8 MSB
				addressER = (addressER<<8) | bootLoader_ReceiveChar();
    74b0:	89 81       	ldd	r24, Y+1	; 0x01
    74b2:	a8 2f       	mov	r26, r24
    74b4:	b0 e0       	ldi	r27, 0x00	; 0
    74b6:	eb 85       	ldd	r30, Y+11	; 0x0b
    74b8:	fc 85       	ldd	r31, Y+12	; 0x0c
    74ba:	ea 2b       	or	r30, r26
    74bc:	fb 2b       	or	r31, r27
    74be:	f8 87       	std	Y+8, r31	; 0x08
    74c0:	ef 83       	std	Y+7, r30	; 0x07
    74c2:	c5 cf       	rjmp	.-118    	; 0x744e <main+0x1cc>
			else
			{
				bootLoader_SendChar(0);
			}
			
		} else if (val == 'C')
    74c4:	23 e4       	ldi	r18, 0x43	; 67
    74c6:	f2 16       	cp	r15, r18
    74c8:	09 f0       	breq	.+2      	; 0x74cc <main+0x24a>
    74ca:	8e c0       	rjmp	.+284    	; 0x75e8 <main+0x366>
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    74cc:	ce 01       	movw	r24, r28
    74ce:	01 96       	adiw	r24, 0x01	; 1
    74d0:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
    74d4:	ce 01       	movw	r24, r28
    74d6:	01 96       	adiw	r24, 0x01	; 1
    74d8:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
		{
			uint16_t size;
			size = bootLoader_ReceiveChar() << 8;				// Load high byte of buffersize
			size |= bootLoader_ReceiveChar();
			
			addressFW = bootLoader_CopyEEPROMToFlash(addressER, addressFW, size); 
    74dc:	d9 80       	ldd	r13, Y+1	; 0x01
    74de:	30 e0       	ldi	r19, 0x00	; 0
    74e0:	d3 2a       	or	r13, r19
static inline uint16_t bootLoader_CopyEEPROMToFlash(uint16_t eAddress, uint16_t fAddress, pagebuf_t size)
{
	pagebuf_t cnt;
	uint8_t *tmp = gBuffer;

	if (size > 128)
    74e2:	80 e8       	ldi	r24, 0x80	; 128
    74e4:	8d 15       	cp	r24, r13
    74e6:	18 f0       	brcs	.+6      	; 0x74ee <main+0x26c>
    74e8:	6f 80       	ldd	r6, Y+7	; 0x07
    74ea:	78 84       	ldd	r7, Y+8	; 0x08
    74ec:	48 c0       	rjmp	.+144    	; 0x757e <main+0x2fc>
    74ee:	90 e6       	ldi	r25, 0x60	; 96
    74f0:	a9 2e       	mov	r10, r25
    74f2:	90 e0       	ldi	r25, 0x00	; 0
    74f4:	b9 2e       	mov	r11, r25
    74f6:	8f 80       	ldd	r8, Y+7	; 0x07
    74f8:	98 84       	ldd	r9, Y+8	; 0x08
}

static void (*jump_to_app1)(void) = 0x0000;

int main(void)
{
    74fa:	9f e7       	ldi	r25, 0x7F	; 127
    74fc:	d9 0e       	add	r13, r25
				bootLoader_SendChar( gBuffer[cnt] );
				eAddress++;
			}
			fAddress = bootLoader_WriteFlashPage(fAddress, 128);
			size = size - 128;
		} while (size > 128);
    74fe:	ed 2c       	mov	r14, r13
    7500:	ee 1c       	adc	r14, r14
    7502:	ee 24       	eor	r14, r14
    7504:	ee 1c       	adc	r14, r14
    7506:	a1 e8       	ldi	r26, 0x81	; 129
    7508:	da 0e       	add	r13, r26
    750a:	0e 2d       	mov	r16, r14
    750c:	10 e0       	ldi	r17, 0x00	; 0
    750e:	0f 5f       	subi	r16, 0xFF	; 255
    7510:	1f 4f       	sbci	r17, 0xFF	; 255
    7512:	16 95       	lsr	r17
    7514:	10 2f       	mov	r17, r16
    7516:	00 27       	eor	r16, r16
    7518:	17 95       	ror	r17
    751a:	07 95       	ror	r16
    751c:	0a 0d       	add	r16, r10
    751e:	1b 1d       	adc	r17, r11
static inline uint16_t bootLoader_CopyEEPROMToFlash(uint16_t eAddress, uint16_t fAddress, pagebuf_t size)
{
	pagebuf_t cnt;
	uint8_t *tmp = gBuffer;

	if (size > 128)
    7520:	25 01       	movw	r4, r10
    7522:	34 01       	movw	r6, r8
    7524:	ff 24       	eor	r15, r15
	{
		do {
			for (cnt = 0; cnt < sizeof(gBuffer); cnt++) {
				*tmp++ = eeprom_read_byte((uint8_t*)eAddress);
    7526:	c3 01       	movw	r24, r6
    7528:	0e 94 00 3e 	call	0x7c00	; 0x7c00 <__eerd_byte_m32>
    752c:	f2 01       	movw	r30, r4
    752e:	81 93       	st	Z+, r24
    7530:	2f 01       	movw	r4, r30
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7532:	ef 2d       	mov	r30, r15
    7534:	f0 e0       	ldi	r31, 0x00	; 0
    7536:	e0 5a       	subi	r30, 0xA0	; 160
    7538:	ff 4f       	sbci	r31, 0xFF	; 255
    753a:	80 81       	ld	r24, Z
    753c:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    7540:	80 ee       	ldi	r24, 0xE0	; 224
    7542:	90 e0       	ldi	r25, 0x00	; 0
    7544:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
	{
		do {
			for (cnt = 0; cnt < sizeof(gBuffer); cnt++) {
				*tmp++ = eeprom_read_byte((uint8_t*)eAddress);
				bootLoader_SendChar( gBuffer[cnt] );
				eAddress++;
    7548:	08 94       	sec
    754a:	61 1c       	adc	r6, r1
    754c:	71 1c       	adc	r7, r1
	uint8_t *tmp = gBuffer;

	if (size > 128)
	{
		do {
			for (cnt = 0; cnt < sizeof(gBuffer); cnt++) {
    754e:	f3 94       	inc	r15
    7550:	f0 e8       	ldi	r31, 0x80	; 128
    7552:	ff 16       	cp	r15, r31
    7554:	41 f7       	brne	.-48     	; 0x7526 <main+0x2a4>
				*tmp++ = eeprom_read_byte((uint8_t*)eAddress);
				bootLoader_SendChar( gBuffer[cnt] );
				eAddress++;
			}
			fAddress = bootLoader_WriteFlashPage(fAddress, 128);
    7556:	c1 01       	movw	r24, r2
    7558:	60 e8       	ldi	r22, 0x80	; 128
    755a:	0e 94 76 38 	call	0x70ec	; 0x70ec <bootLoader_WriteFlashPage>
    755e:	1c 01       	movw	r2, r24
    7560:	20 e8       	ldi	r18, 0x80	; 128
    7562:	30 e0       	ldi	r19, 0x00	; 0
    7564:	82 0e       	add	r8, r18
    7566:	93 1e       	adc	r9, r19
    7568:	a2 0e       	add	r10, r18
    756a:	b3 1e       	adc	r11, r19
			size = size - 128;
		} while (size > 128);
    756c:	a0 16       	cp	r10, r16
    756e:	b1 06       	cpc	r11, r17
    7570:	b9 f6       	brne	.-82     	; 0x7520 <main+0x29e>
}

static void (*jump_to_app1)(void) = 0x0000;

int main(void)
{
    7572:	30 e8       	ldi	r19, 0x80	; 128
    7574:	d3 0e       	add	r13, r19
    7576:	e7 94       	ror	r14
    7578:	ee 24       	eor	r14, r14
    757a:	e7 94       	ror	r14
    757c:	de 0c       	add	r13, r14
    757e:	10 e6       	ldi	r17, 0x60	; 96
    7580:	e1 2e       	mov	r14, r17
    7582:	10 e0       	ldi	r17, 0x00	; 0
    7584:	f1 2e       	mov	r15, r17
    7586:	00 e0       	ldi	r16, 0x00	; 0
    7588:	10 e0       	ldi	r17, 0x00	; 0
    758a:	19 c0       	rjmp	.+50     	; 0x75be <main+0x33c>
		} while (size > 128);
	}
	
	tmp = gBuffer;
	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) {
		*tmp++ = (cnt < size) ? eeprom_read_byte((uint8_t*)eAddress) : 0xFF;
    758c:	cd 14       	cp	r12, r13
    758e:	10 f0       	brcs	.+4      	; 0x7594 <main+0x312>
    7590:	8f ef       	ldi	r24, 0xFF	; 255
    7592:	05 c0       	rjmp	.+10     	; 0x759e <main+0x31c>
    7594:	c8 01       	movw	r24, r16
    7596:	86 0d       	add	r24, r6
    7598:	97 1d       	adc	r25, r7
    759a:	0e 94 00 3e 	call	0x7c00	; 0x7c00 <__eerd_byte_m32>
    759e:	d7 01       	movw	r26, r14
    75a0:	8d 93       	st	X+, r24
    75a2:	7d 01       	movw	r14, r26
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    75a4:	ec 2d       	mov	r30, r12
    75a6:	f0 e0       	ldi	r31, 0x00	; 0
    75a8:	e0 5a       	subi	r30, 0xA0	; 160
    75aa:	ff 4f       	sbci	r31, 0xFF	; 255
    75ac:	80 81       	ld	r24, Z
    75ae:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    75b2:	80 ee       	ldi	r24, 0xE0	; 224
    75b4:	90 e0       	ldi	r25, 0x00	; 0
    75b6:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
    75ba:	0f 5f       	subi	r16, 0xFF	; 255
    75bc:	1f 4f       	sbci	r17, 0xFF	; 255
    75be:	c0 2e       	mov	r12, r16
			size = size - 128;
		} while (size > 128);
	}
	
	tmp = gBuffer;
	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) {
    75c0:	b0 ee       	ldi	r27, 0xE0	; 224
    75c2:	eb 16       	cp	r14, r27
    75c4:	b0 e0       	ldi	r27, 0x00	; 0
    75c6:	fb 06       	cpc	r15, r27
    75c8:	09 f7       	brne	.-62     	; 0x758c <main+0x30a>
		*tmp++ = (cnt < size) ? eeprom_read_byte((uint8_t*)eAddress) : 0xFF;
		bootLoader_SendChar( gBuffer[cnt] );
		eAddress++;
	}
	return bootLoader_WriteFlashPage(fAddress, size);
    75ca:	c1 01       	movw	r24, r2
    75cc:	6d 2d       	mov	r22, r13
    75ce:	0e 94 76 38 	call	0x70ec	; 0x70ec <bootLoader_WriteFlashPage>
    75d2:	1c 01       	movw	r2, r24
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    75d4:	13 e2       	ldi	r17, 0x23	; 35
    75d6:	10 93 e0 00 	sts	0x00E0, r17
	HAL_comm_UART_Send(&uart_handle);
    75da:	80 ee       	ldi	r24, 0xE0	; 224
    75dc:	90 e0       	ldi	r25, 0x00	; 0
    75de:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    75e2:	10 93 e0 00 	sts	0x00E0, r17
    75e6:	fc c1       	rjmp	.+1016   	; 0x79e0 <main+0x75e>
			
			addressFW = bootLoader_CopyEEPROMToFlash(addressER, addressFW, size); 
			bootLoader_SendChar('#');
			bootLoader_SendChar('#');
		
		} else if (val == 'r')
    75e8:	e2 e7       	ldi	r30, 0x72	; 114
    75ea:	fe 16       	cp	r15, r30
    75ec:	09 f0       	breq	.+2      	; 0x75f0 <main+0x36e>
    75ee:	69 c0       	rjmp	.+210    	; 0x76c2 <main+0x440>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    75f0:	f6 e4       	ldi	r31, 0x46	; 70
    75f2:	f0 93 e0 00 	sts	0x00E0, r31
	HAL_comm_UART_Send(&uart_handle);
    75f6:	80 ee       	ldi	r24, 0xE0	; 224
    75f8:	90 e0       	ldi	r25, 0x00	; 0
    75fa:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    75fe:	22 e5       	ldi	r18, 0x52	; 82
    7600:	20 93 e0 00 	sts	0x00E0, r18
	HAL_comm_UART_Send(&uart_handle);
    7604:	80 ee       	ldi	r24, 0xE0	; 224
    7606:	90 e0       	ldi	r25, 0x00	; 0
    7608:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    760c:	3a 85       	ldd	r19, Y+10	; 0x0a
    760e:	30 93 e0 00 	sts	0x00E0, r19
	HAL_comm_UART_Send(&uart_handle);
    7612:	80 ee       	ldi	r24, 0xE0	; 224
    7614:	90 e0       	ldi	r25, 0x00	; 0
    7616:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    761a:	89 85       	ldd	r24, Y+9	; 0x09
    761c:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    7620:	80 ee       	ldi	r24, 0xE0	; 224
    7622:	90 e0       	ldi	r25, 0x00	; 0
    7624:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7628:	96 e4       	ldi	r25, 0x46	; 70
    762a:	90 93 e0 00 	sts	0x00E0, r25
	HAL_comm_UART_Send(&uart_handle);
    762e:	80 ee       	ldi	r24, 0xE0	; 224
    7630:	90 e0       	ldi	r25, 0x00	; 0
    7632:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7636:	07 e5       	ldi	r16, 0x57	; 87
    7638:	00 93 e0 00 	sts	0x00E0, r16
	HAL_comm_UART_Send(&uart_handle);
    763c:	80 ee       	ldi	r24, 0xE0	; 224
    763e:	90 e0       	ldi	r25, 0x00	; 0
    7640:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7644:	30 92 e0 00 	sts	0x00E0, r3
	HAL_comm_UART_Send(&uart_handle);
    7648:	80 ee       	ldi	r24, 0xE0	; 224
    764a:	90 e0       	ldi	r25, 0x00	; 0
    764c:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7650:	20 92 e0 00 	sts	0x00E0, r2
	HAL_comm_UART_Send(&uart_handle);
    7654:	80 ee       	ldi	r24, 0xE0	; 224
    7656:	90 e0       	ldi	r25, 0x00	; 0
    7658:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    765c:	15 e4       	ldi	r17, 0x45	; 69
    765e:	10 93 e0 00 	sts	0x00E0, r17
	HAL_comm_UART_Send(&uart_handle);
    7662:	80 ee       	ldi	r24, 0xE0	; 224
    7664:	90 e0       	ldi	r25, 0x00	; 0
    7666:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    766a:	a2 e5       	ldi	r26, 0x52	; 82
    766c:	a0 93 e0 00 	sts	0x00E0, r26
	HAL_comm_UART_Send(&uart_handle);
    7670:	80 ee       	ldi	r24, 0xE0	; 224
    7672:	90 e0       	ldi	r25, 0x00	; 0
    7674:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7678:	b8 85       	ldd	r27, Y+8	; 0x08
    767a:	b0 93 e0 00 	sts	0x00E0, r27
	HAL_comm_UART_Send(&uart_handle);
    767e:	80 ee       	ldi	r24, 0xE0	; 224
    7680:	90 e0       	ldi	r25, 0x00	; 0
    7682:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7686:	ef 81       	ldd	r30, Y+7	; 0x07
    7688:	e0 93 e0 00 	sts	0x00E0, r30
	HAL_comm_UART_Send(&uart_handle);
    768c:	80 ee       	ldi	r24, 0xE0	; 224
    768e:	90 e0       	ldi	r25, 0x00	; 0
    7690:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7694:	10 93 e0 00 	sts	0x00E0, r17
	HAL_comm_UART_Send(&uart_handle);
    7698:	80 ee       	ldi	r24, 0xE0	; 224
    769a:	90 e0       	ldi	r25, 0x00	; 0
    769c:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    76a0:	00 93 e0 00 	sts	0x00E0, r16
	HAL_comm_UART_Send(&uart_handle);
    76a4:	80 ee       	ldi	r24, 0xE0	; 224
    76a6:	90 e0       	ldi	r25, 0x00	; 0
    76a8:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    76ac:	fe 81       	ldd	r31, Y+6	; 0x06
    76ae:	f0 93 e0 00 	sts	0x00E0, r31
	HAL_comm_UART_Send(&uart_handle);
    76b2:	80 ee       	ldi	r24, 0xE0	; 224
    76b4:	90 e0       	ldi	r25, 0x00	; 0
    76b6:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    76ba:	2d 81       	ldd	r18, Y+5	; 0x05
    76bc:	20 93 e0 00 	sts	0x00E0, r18
    76c0:	8f c1       	rjmp	.+798    	; 0x79e0 <main+0x75e>
			bootLoader_SendChar('W');
			bootLoader_SendChar((addressEW>>8) & 0xFF);
			bootLoader_SendChar(addressEW & 0xFF);

		// Start buffer load
		} else if (val == 'B') {
    76c2:	32 e4       	ldi	r19, 0x42	; 66
    76c4:	f3 16       	cp	r15, r19
    76c6:	09 f0       	breq	.+2      	; 0x76ca <main+0x448>
    76c8:	aa c0       	rjmp	.+340    	; 0x781e <main+0x59c>
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    76ca:	ce 01       	movw	r24, r28
    76cc:	01 96       	adiw	r24, 0x01	; 1
    76ce:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
			bootLoader_SendChar(addressEW & 0xFF);

		// Start buffer load
		} else if (val == 'B') {
			uint16_t size;
			size = bootLoader_ReceiveChar() << 8;				// Load high byte of buffersize
    76d2:	89 81       	ldd	r24, Y+1	; 0x01
    76d4:	8c 83       	std	Y+4, r24	; 0x04
    76d6:	1b 82       	std	Y+3, r1	; 0x03
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    76d8:	ce 01       	movw	r24, r28
    76da:	01 96       	adiw	r24, 0x01	; 1
    76dc:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>

		// Start buffer load
		} else if (val == 'B') {
			uint16_t size;
			size = bootLoader_ReceiveChar() << 8;				// Load high byte of buffersize
			size |= bootLoader_ReceiveChar();
    76e0:	89 81       	ldd	r24, Y+1	; 0x01
    76e2:	08 2f       	mov	r16, r24
    76e4:	10 e0       	ldi	r17, 0x00	; 0
    76e6:	ab 81       	ldd	r26, Y+3	; 0x03
    76e8:	bc 81       	ldd	r27, Y+4	; 0x04
    76ea:	0a 2b       	or	r16, r26
    76ec:	1b 2b       	or	r17, r27
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    76ee:	f0 92 e0 00 	sts	0x00E0, r15
	HAL_comm_UART_Send(&uart_handle);
    76f2:	80 ee       	ldi	r24, 0xE0	; 224
    76f4:	90 e0       	ldi	r25, 0x00	; 0
    76f6:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    76fa:	b1 e3       	ldi	r27, 0x31	; 49
    76fc:	b0 93 e0 00 	sts	0x00E0, r27
	HAL_comm_UART_Send(&uart_handle);
    7700:	80 ee       	ldi	r24, 0xE0	; 224
    7702:	90 e0       	ldi	r25, 0x00	; 0
    7704:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    7708:	ce 01       	movw	r24, r28
    770a:	01 96       	adiw	r24, 0x01	; 1
    770c:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
	return x;
    7710:	f9 80       	ldd	r15, Y+1	; 0x01
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7712:	f0 92 e0 00 	sts	0x00E0, r15
	HAL_comm_UART_Send(&uart_handle);
    7716:	80 ee       	ldi	r24, 0xE0	; 224
    7718:	90 e0       	ldi	r25, 0x00	; 0
    771a:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
			bootLoader_SendChar('B');
			bootLoader_SendChar('1');				// Load low byte of buffersize
			val = bootLoader_ReceiveChar();				// Load memory type ('E' or 'F')
			bootLoader_SendChar(val);
			
			if (val == 'F')
    771e:	e6 e4       	ldi	r30, 0x46	; 70
    7720:	fe 16       	cp	r15, r30
    7722:	09 f0       	breq	.+2      	; 0x7726 <main+0x4a4>
    7724:	4f c0       	rjmp	.+158    	; 0x77c4 <main+0x542>
			{
				if (size > 128)
    7726:	01 38       	cpi	r16, 0x81	; 129
    7728:	11 05       	cpc	r17, r1
    772a:	a8 f1       	brcs	.+106    	; 0x7796 <main+0x514>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    772c:	f0 e5       	ldi	r31, 0x50	; 80
    772e:	f0 93 e0 00 	sts	0x00E0, r31
	HAL_comm_UART_Send(&uart_handle);
    7732:	80 ee       	ldi	r24, 0xE0	; 224
    7734:	90 e0       	ldi	r25, 0x00	; 0
    7736:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    773a:	20 e3       	ldi	r18, 0x30	; 48
    773c:	20 93 e0 00 	sts	0x00E0, r18
	HAL_comm_UART_Send(&uart_handle);
    7740:	80 ee       	ldi	r24, 0xE0	; 224
    7742:	90 e0       	ldi	r25, 0x00	; 0
    7744:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
    7748:	78 01       	movw	r14, r16
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    774a:	30 e5       	ldi	r19, 0x50	; 80
    774c:	30 93 e0 00 	sts	0x00E0, r19
	HAL_comm_UART_Send(&uart_handle);
    7750:	80 ee       	ldi	r24, 0xE0	; 224
    7752:	90 e0       	ldi	r25, 0x00	; 0
    7754:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7758:	81 e3       	ldi	r24, 0x31	; 49
    775a:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    775e:	80 ee       	ldi	r24, 0xE0	; 224
    7760:	90 e0       	ldi	r25, 0x00	; 0
    7762:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
					bootLoader_SendChar('P');
					bootLoader_SendChar('0');
					do{
						bootLoader_SendChar('P');
						bootLoader_SendChar('1');
						bootLoader_ReceiveBuffer(128); //sizeof(Buffer) == SPM_PAGESIZE
    7766:	80 e8       	ldi	r24, 0x80	; 128
    7768:	0e 94 15 38 	call	0x702a	; 0x702a <bootLoader_ReceiveBuffer>
						addressFW = bootLoader_WriteFlashPage(addressFW, 128);
    776c:	c1 01       	movw	r24, r2
    776e:	60 e8       	ldi	r22, 0x80	; 128
    7770:	0e 94 76 38 	call	0x70ec	; 0x70ec <bootLoader_WriteFlashPage>
    7774:	1c 01       	movw	r2, r24
						size = size - 128;
    7776:	a0 e8       	ldi	r26, 0x80	; 128
    7778:	bf ef       	ldi	r27, 0xFF	; 255
    777a:	ea 0e       	add	r14, r26
    777c:	fb 1e       	adc	r15, r27
					} while (size > 128);
    777e:	b1 e8       	ldi	r27, 0x81	; 129
    7780:	eb 16       	cp	r14, r27
    7782:	f1 04       	cpc	r15, r1
    7784:	10 f7       	brcc	.-60     	; 0x774a <main+0x4c8>
}

static void (*jump_to_app1)(void) = 0x0000;

int main(void)
{
    7786:	01 58       	subi	r16, 0x81	; 129
    7788:	10 40       	sbci	r17, 0x00	; 0
    778a:	c8 01       	movw	r24, r16
    778c:	80 78       	andi	r24, 0x80	; 128
    778e:	0f 5f       	subi	r16, 0xFF	; 255
    7790:	1f 4f       	sbci	r17, 0xFF	; 255
    7792:	08 1b       	sub	r16, r24
    7794:	19 0b       	sbc	r17, r25
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7796:	e0 e5       	ldi	r30, 0x50	; 80
    7798:	e0 93 e0 00 	sts	0x00E0, r30
	HAL_comm_UART_Send(&uart_handle);
    779c:	80 ee       	ldi	r24, 0xE0	; 224
    779e:	90 e0       	ldi	r25, 0x00	; 0
    77a0:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    77a4:	f2 e3       	ldi	r31, 0x32	; 50
    77a6:	f0 93 e0 00 	sts	0x00E0, r31
	HAL_comm_UART_Send(&uart_handle);
    77aa:	80 ee       	ldi	r24, 0xE0	; 224
    77ac:	90 e0       	ldi	r25, 0x00	; 0
    77ae:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
						size = size - 128;
					} while (size > 128);
				}
				bootLoader_SendChar('P');
				bootLoader_SendChar('2');
				bootLoader_ReceiveBuffer((uint8_t)size);
    77b2:	80 2f       	mov	r24, r16
    77b4:	0e 94 15 38 	call	0x702a	; 0x702a <bootLoader_ReceiveBuffer>
				addressFW = bootLoader_WriteFlashPage(addressFW, (uint8_t)size);
    77b8:	c1 01       	movw	r24, r2
    77ba:	60 2f       	mov	r22, r16
    77bc:	0e 94 76 38 	call	0x70ec	; 0x70ec <bootLoader_WriteFlashPage>
    77c0:	1c 01       	movw	r2, r24
    77c2:	05 ce       	rjmp	.-1014   	; 0x73ce <main+0x14c>
				
			}
			else if (val == 'E')
    77c4:	25 e4       	ldi	r18, 0x45	; 69
    77c6:	f2 16       	cp	r15, r18
    77c8:	09 f0       	breq	.+2      	; 0x77cc <main+0x54a>
    77ca:	01 ce       	rjmp	.-1022   	; 0x73ce <main+0x14c>
			{
				if (size > SPM_PAGESIZE)
    77cc:	01 38       	cpi	r16, 0x81	; 129
    77ce:	11 05       	cpc	r17, r1
    77d0:	d8 f0       	brcs	.+54     	; 0x7808 <main+0x586>
    77d2:	78 01       	movw	r14, r16
				{
					do{
						bootLoader_ReceiveBuffer(SPM_PAGESIZE); //sizeof(Buffer) == SPM_PAGESIZE
    77d4:	80 e8       	ldi	r24, 0x80	; 128
    77d6:	0e 94 15 38 	call	0x702a	; 0x702a <bootLoader_ReceiveBuffer>
						addressEW = bootLoader_WriteEEPROM(addressEW, SPM_PAGESIZE);
    77da:	8d 81       	ldd	r24, Y+5	; 0x05
    77dc:	9e 81       	ldd	r25, Y+6	; 0x06
    77de:	60 e8       	ldi	r22, 0x80	; 128
    77e0:	0e 94 ed 38 	call	0x71da	; 0x71da <bootLoader_WriteEEPROM>
    77e4:	9e 83       	std	Y+6, r25	; 0x06
    77e6:	8d 83       	std	Y+5, r24	; 0x05
						size = size - SPM_PAGESIZE;
    77e8:	80 e8       	ldi	r24, 0x80	; 128
    77ea:	9f ef       	ldi	r25, 0xFF	; 255
    77ec:	e8 0e       	add	r14, r24
    77ee:	f9 1e       	adc	r15, r25
					} while (size > SPM_PAGESIZE);
    77f0:	91 e8       	ldi	r25, 0x81	; 129
    77f2:	e9 16       	cp	r14, r25
    77f4:	f1 04       	cpc	r15, r1
    77f6:	70 f7       	brcc	.-36     	; 0x77d4 <main+0x552>
}

static void (*jump_to_app1)(void) = 0x0000;

int main(void)
{
    77f8:	01 58       	subi	r16, 0x81	; 129
    77fa:	10 40       	sbci	r17, 0x00	; 0
    77fc:	c8 01       	movw	r24, r16
    77fe:	80 78       	andi	r24, 0x80	; 128
    7800:	0f 5f       	subi	r16, 0xFF	; 255
    7802:	1f 4f       	sbci	r17, 0xFF	; 255
    7804:	08 1b       	sub	r16, r24
    7806:	19 0b       	sbc	r17, r25
						bootLoader_ReceiveBuffer(SPM_PAGESIZE); //sizeof(Buffer) == SPM_PAGESIZE
						addressEW = bootLoader_WriteEEPROM(addressEW, SPM_PAGESIZE);
						size = size - SPM_PAGESIZE;
					} while (size > SPM_PAGESIZE);
				}
				bootLoader_ReceiveBuffer((uint8_t)size);
    7808:	80 2f       	mov	r24, r16
    780a:	0e 94 15 38 	call	0x702a	; 0x702a <bootLoader_ReceiveBuffer>
				addressEW = bootLoader_WriteEEPROM(addressEW, (uint8_t)size);
    780e:	8d 81       	ldd	r24, Y+5	; 0x05
    7810:	9e 81       	ldd	r25, Y+6	; 0x06
    7812:	60 2f       	mov	r22, r16
    7814:	0e 94 ed 38 	call	0x71da	; 0x71da <bootLoader_WriteEEPROM>
    7818:	9e 83       	std	Y+6, r25	; 0x06
    781a:	8d 83       	std	Y+5, r24	; 0x05
    781c:	d8 cd       	rjmp	.-1104   	; 0x73ce <main+0x14c>
			}
			
			
		// Block read
		} else if (val == 'g') {
    781e:	a7 e6       	ldi	r26, 0x67	; 103
    7820:	fa 16       	cp	r15, r26
    7822:	09 f0       	breq	.+2      	; 0x7826 <main+0x5a4>
    7824:	67 c0       	rjmp	.+206    	; 0x78f4 <main+0x672>
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    7826:	ce 01       	movw	r24, r28
    7828:	01 96       	adiw	r24, 0x01	; 1
    782a:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
    782e:	ce 01       	movw	r24, r28
    7830:	01 96       	adiw	r24, 0x01	; 1
    7832:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
	return x;
    7836:	d9 80       	ldd	r13, Y+1	; 0x01
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    7838:	ce 01       	movw	r24, r28
    783a:	01 96       	adiw	r24, 0x01	; 1
    783c:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
	return x;
    7840:	89 81       	ldd	r24, Y+1	; 0x01
			pagebuf_t size;
			size = bootLoader_ReceiveChar() << 8;				// Load high byte of buffersize
			size |= bootLoader_ReceiveChar();				// Load low byte of buffersize
			val = bootLoader_ReceiveChar();				// Get memtype

			if (val == 'F') {
    7842:	86 34       	cpi	r24, 0x46	; 70
    7844:	c1 f5       	brne	.+112    	; 0x78b6 <main+0x634>
	return address;
}

static inline uint16_t bootLoader_ReadFlashPage(uint16_t waddr, pagebuf_t size)
{
	uint32_t baddr = (uint32_t)waddr<<1;
    7846:	e9 85       	ldd	r30, Y+9	; 0x09
    7848:	fa 85       	ldd	r31, Y+10	; 0x0a
    784a:	7f 01       	movw	r14, r30
    784c:	00 e0       	ldi	r16, 0x00	; 0
    784e:	10 e0       	ldi	r17, 0x00	; 0
    7850:	ee 0c       	add	r14, r14
    7852:	ff 1c       	adc	r15, r15
    7854:	00 1f       	adc	r16, r16
    7856:	11 1f       	adc	r17, r17
		}
		bootLoader_SendChar(data);			// send LSB
		bootLoader_SendChar((data >> 8));		// send MSB
		baddr += 2;			// Select next word in memory
		size -= 2;			// Subtract two bytes from number of bytes to read
	} while (size);				// Repeat until block has been read
    7858:	be 2c       	mov	r11, r14
    785a:	bd 0c       	add	r11, r13
	uint32_t baddr = (uint32_t)waddr<<1;
	uint16_t data;

	do {
		// don't read bootloader
		if ( baddr < APP_END ) {
    785c:	ff ef       	ldi	r31, 0xFF	; 255
    785e:	ef 16       	cp	r14, r31
    7860:	ff e6       	ldi	r31, 0x6F	; 111
    7862:	ff 06       	cpc	r15, r31
    7864:	f0 e0       	ldi	r31, 0x00	; 0
    7866:	0f 07       	cpc	r16, r31
    7868:	f0 e0       	ldi	r31, 0x00	; 0
    786a:	1f 07       	cpc	r17, r31
    786c:	20 f0       	brcs	.+8      	; 0x7876 <main+0x5f4>
    786e:	cc 24       	eor	r12, r12
    7870:	ca 94       	dec	r12
    7872:	dc 2c       	mov	r13, r12
    7874:	03 c0       	rjmp	.+6      	; 0x787c <main+0x5fa>
			data = pgm_read_word_near(baddr);
    7876:	f7 01       	movw	r30, r14
    7878:	c5 90       	lpm	r12, Z+
    787a:	d4 90       	lpm	r13, Z+
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    787c:	c0 92 e0 00 	sts	0x00E0, r12
	HAL_comm_UART_Send(&uart_handle);
    7880:	80 ee       	ldi	r24, 0xE0	; 224
    7882:	90 e0       	ldi	r25, 0x00	; 0
    7884:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7888:	d0 92 e0 00 	sts	0x00E0, r13
	HAL_comm_UART_Send(&uart_handle);
    788c:	80 ee       	ldi	r24, 0xE0	; 224
    788e:	90 e0       	ldi	r25, 0x00	; 0
    7890:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
		else {
			data = 0xFFFF; // fake empty
		}
		bootLoader_SendChar(data);			// send LSB
		bootLoader_SendChar((data >> 8));		// send MSB
		baddr += 2;			// Select next word in memory
    7894:	82 e0       	ldi	r24, 0x02	; 2
    7896:	90 e0       	ldi	r25, 0x00	; 0
    7898:	a0 e0       	ldi	r26, 0x00	; 0
    789a:	b0 e0       	ldi	r27, 0x00	; 0
    789c:	e8 0e       	add	r14, r24
    789e:	f9 1e       	adc	r15, r25
    78a0:	0a 1f       	adc	r16, r26
    78a2:	1b 1f       	adc	r17, r27
		size -= 2;			// Subtract two bytes from number of bytes to read
	} while (size);				// Repeat until block has been read
    78a4:	be 14       	cp	r11, r14
    78a6:	d1 f6       	brne	.-76     	; 0x785c <main+0x5da>

	return baddr>>1;
    78a8:	16 95       	lsr	r17
    78aa:	07 95       	ror	r16
    78ac:	f7 94       	ror	r15
    78ae:	e7 94       	ror	r14
    78b0:	fa 86       	std	Y+10, r15	; 0x0a
    78b2:	e9 86       	std	Y+9, r14	; 0x09
    78b4:	8c cd       	rjmp	.-1256   	; 0x73ce <main+0x14c>
			size |= bootLoader_ReceiveChar();				// Load low byte of buffersize
			val = bootLoader_ReceiveChar();				// Get memtype

			if (val == 'F') {
				addressFR = bootLoader_ReadFlashPage(addressFR, size);
			} else if (val == 'E') {
    78b6:	85 34       	cpi	r24, 0x45	; 69
    78b8:	09 f0       	breq	.+2      	; 0x78bc <main+0x63a>
    78ba:	89 cd       	rjmp	.-1262   	; 0x73ce <main+0x14c>
    78bc:	0f 81       	ldd	r16, Y+7	; 0x07
    78be:	18 85       	ldd	r17, Y+8	; 0x08
{
	do {
		bootLoader_SendChar( eeprom_read_byte( (uint8_t*)address ) );
		address++;
		size--;				// Decrease number of bytes to read
	} while (size);				// Repeat until block has been read
    78c0:	ff 80       	ldd	r15, Y+7	; 0x07
    78c2:	fd 0c       	add	r15, r13
}

static inline uint16_t bootLoader_ReadEEPROM(uint16_t address, pagebuf_t size)
{
	do {
		bootLoader_SendChar( eeprom_read_byte( (uint8_t*)address ) );
    78c4:	c8 01       	movw	r24, r16
    78c6:	0e 94 00 3e 	call	0x7c00	; 0x7c00 <__eerd_byte_m32>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    78ca:	80 93 e0 00 	sts	0x00E0, r24
	HAL_comm_UART_Send(&uart_handle);
    78ce:	80 ee       	ldi	r24, 0xE0	; 224
    78d0:	90 e0       	ldi	r25, 0x00	; 0
    78d2:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>

static inline uint16_t bootLoader_ReadEEPROM(uint16_t address, pagebuf_t size)
{
	do {
		bootLoader_SendChar( eeprom_read_byte( (uint8_t*)address ) );
		address++;
    78d6:	0f 5f       	subi	r16, 0xFF	; 255
    78d8:	1f 4f       	sbci	r17, 0xFF	; 255
		size--;				// Decrease number of bytes to read
	} while (size);				// Repeat until block has been read
    78da:	f0 16       	cp	r15, r16
    78dc:	99 f7       	brne	.-26     	; 0x78c4 <main+0x642>
    78de:	da 94       	dec	r13
    78e0:	8d 2d       	mov	r24, r13
    78e2:	90 e0       	ldi	r25, 0x00	; 0
    78e4:	01 96       	adiw	r24, 0x01	; 1
    78e6:	af 81       	ldd	r26, Y+7	; 0x07
    78e8:	b8 85       	ldd	r27, Y+8	; 0x08
    78ea:	a8 0f       	add	r26, r24
    78ec:	b9 1f       	adc	r27, r25
    78ee:	b8 87       	std	Y+8, r27	; 0x08
    78f0:	af 83       	std	Y+7, r26	; 0x07
    78f2:	6d cd       	rjmp	.-1318   	; 0x73ce <main+0x14c>
			} else if (val == 'E') {
				addressER = bootLoader_ReadEEPROM(addressER, size);
			}

		/*Chip erase*/
 		} else if (val == 'e') {
    78f4:	b5 e6       	ldi	r27, 0x65	; 101
    78f6:	fb 16       	cp	r15, r27
    78f8:	09 f0       	breq	.+2      	; 0x78fc <main+0x67a>
    78fa:	46 c0       	rjmp	.+140    	; 0x7988 <main+0x706>
}

static uint8_t bootLoader_ReceiveChar(void)
{
	uint16_t x;
	HAL_comm_UART_Receive(&x);
    78fc:	ce 01       	movw	r24, r28
    78fe:	01 96       	adiw	r24, 0x01	; 1
    7900:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HAL_comm_UART_Receive>
	return x;
    7904:	89 81       	ldd	r24, Y+1	; 0x01
			}

		/*Chip erase*/
 		} else if (val == 'e') {
			val = bootLoader_ReceiveChar();
			if(val == 'F')
    7906:	86 34       	cpi	r24, 0x46	; 70
    7908:	e9 f4       	brne	.+58     	; 0x7944 <main+0x6c2>
    790a:	e0 e0       	ldi	r30, 0x00	; 0
    790c:	f0 e0       	ldi	r31, 0x00	; 0
static inline void bootLoader_EraseFlash(void)
{
	// erase only main section (bootloader protection)
	uint32_t addr = 0;
	while (APP_END > addr) {
		boot_page_erase(addr);		// Perform page erase
    790e:	23 e0       	ldi	r18, 0x03	; 3
    7910:	20 93 57 00 	sts	0x0057, r18
    7914:	e8 95       	spm
		boot_spm_busy_wait();		// Wait until the memory is erased.
    7916:	07 b6       	in	r0, 0x37	; 55
    7918:	00 fc       	sbrc	r0, 0
    791a:	fd cf       	rjmp	.-6      	; 0x7916 <main+0x694>
    791c:	e0 58       	subi	r30, 0x80	; 128
    791e:	ff 4f       	sbci	r31, 0xFF	; 255

static inline void bootLoader_EraseFlash(void)
{
	// erase only main section (bootloader protection)
	uint32_t addr = 0;
	while (APP_END > addr) {
    7920:	30 e7       	ldi	r19, 0x70	; 112
    7922:	e0 30       	cpi	r30, 0x00	; 0
    7924:	f3 07       	cpc	r31, r19
    7926:	99 f7       	brne	.-26     	; 0x790e <main+0x68c>
		boot_page_erase(addr);		// Perform page erase
		boot_spm_busy_wait();		// Wait until the memory is erased.
		addr += SPM_PAGESIZE;
	}
	boot_rww_enable();
    7928:	81 e1       	ldi	r24, 0x11	; 17
    792a:	80 93 57 00 	sts	0x0057, r24
    792e:	e8 95       	spm
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7930:	9d e0       	ldi	r25, 0x0D	; 13
    7932:	90 93 e0 00 	sts	0x00E0, r25
	HAL_comm_UART_Send(&uart_handle);
    7936:	80 ee       	ldi	r24, 0xE0	; 224
    7938:	90 e0       	ldi	r25, 0x00	; 0
    793a:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
    793e:	22 24       	eor	r2, r2
    7940:	33 24       	eor	r3, r3
    7942:	45 cd       	rjmp	.-1398   	; 0x73ce <main+0x14c>
			{
				bootLoader_EraseFlash();
				addressFW = 0;
				bootLoader_SendChar('\r');				
			}
			else if(val == 'E')
    7944:	85 34       	cpi	r24, 0x45	; 69
    7946:	e9 f4       	brne	.+58     	; 0x7982 <main+0x700>
    7948:	e0 e0       	ldi	r30, 0x00	; 0
    794a:	f0 e0       	ldi	r31, 0x00	; 0
static inline void bootLoader_EraseFlash(void)
{
	// erase only main section (bootloader protection)
	uint32_t addr = 0;
	while (APP_END > addr) {
		boot_page_erase(addr);		// Perform page erase
    794c:	a3 e0       	ldi	r26, 0x03	; 3
    794e:	a0 93 57 00 	sts	0x0057, r26
    7952:	e8 95       	spm
		boot_spm_busy_wait();		// Wait until the memory is erased.
    7954:	07 b6       	in	r0, 0x37	; 55
    7956:	00 fc       	sbrc	r0, 0
    7958:	fd cf       	rjmp	.-6      	; 0x7954 <main+0x6d2>
    795a:	e0 58       	subi	r30, 0x80	; 128
    795c:	ff 4f       	sbci	r31, 0xFF	; 255

static inline void bootLoader_EraseFlash(void)
{
	// erase only main section (bootloader protection)
	uint32_t addr = 0;
	while (APP_END > addr) {
    795e:	b0 e7       	ldi	r27, 0x70	; 112
    7960:	e0 30       	cpi	r30, 0x00	; 0
    7962:	fb 07       	cpc	r31, r27
    7964:	99 f7       	brne	.-26     	; 0x794c <main+0x6ca>
		boot_page_erase(addr);		// Perform page erase
		boot_spm_busy_wait();		// Wait until the memory is erased.
		addr += SPM_PAGESIZE;
	}
	boot_rww_enable();
    7966:	e1 e1       	ldi	r30, 0x11	; 17
    7968:	e0 93 57 00 	sts	0x0057, r30
    796c:	e8 95       	spm
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    796e:	fd e0       	ldi	r31, 0x0D	; 13
    7970:	f0 93 e0 00 	sts	0x00E0, r31
	HAL_comm_UART_Send(&uart_handle);
    7974:	80 ee       	ldi	r24, 0xE0	; 224
    7976:	90 e0       	ldi	r25, 0x00	; 0
    7978:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
    797c:	1e 82       	std	Y+6, r1	; 0x06
    797e:	1d 82       	std	Y+5, r1	; 0x05
    7980:	26 cd       	rjmp	.-1460   	; 0x73ce <main+0x14c>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    7982:	10 92 e0 00 	sts	0x00E0, r1
    7986:	2c c0       	rjmp	.+88     	; 0x79e0 <main+0x75e>
			{
				bootLoader_SendChar(0);
			}

		// Exit upgrade
		} else if (val == 'E') {
    7988:	25 e4       	ldi	r18, 0x45	; 69
    798a:	f2 16       	cp	r15, r18
    798c:	69 f4       	brne	.+26     	; 0x79a8 <main+0x726>
			wdt_enable(EXIT_WDT_TIME); // Enable Watchdog Timer to give reset
    798e:	88 e1       	ldi	r24, 0x18	; 24
    7990:	90 e0       	ldi	r25, 0x00	; 0
    7992:	ac e0       	ldi	r26, 0x0C	; 12
    7994:	0f b6       	in	r0, 0x3f	; 63
    7996:	f8 94       	cli
    7998:	a8 95       	wdr
    799a:	81 bd       	out	0x21, r24	; 33
    799c:	0f be       	out	0x3f, r0	; 63
    799e:	a1 bd       	out	0x21, r26	; 33
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    79a0:	bd e0       	ldi	r27, 0x0D	; 13
    79a2:	b0 93 e0 00 	sts	0x00E0, r27
    79a6:	1c c0       	rjmp	.+56     	; 0x79e0 <main+0x75e>
			bootLoader_SendChar('\r');

		// Return Signature Bytes (it seems that 
		// AVRProg expects the "Atmel-byte" 0x1E last
		// but shows it first in the dialog-window)
		} else if (val == 's') {
    79a8:	e3 e7       	ldi	r30, 0x73	; 115
    79aa:	fe 16       	cp	r15, r30
    79ac:	91 f4       	brne	.+36     	; 0x79d2 <main+0x750>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    79ae:	f2 e0       	ldi	r31, 0x02	; 2
    79b0:	f0 93 e0 00 	sts	0x00E0, r31
	HAL_comm_UART_Send(&uart_handle);
    79b4:	80 ee       	ldi	r24, 0xE0	; 224
    79b6:	90 e0       	ldi	r25, 0x00	; 0
    79b8:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    79bc:	25 e9       	ldi	r18, 0x95	; 149
    79be:	20 93 e0 00 	sts	0x00E0, r18
	HAL_comm_UART_Send(&uart_handle);
    79c2:	80 ee       	ldi	r24, 0xE0	; 224
    79c4:	90 e0       	ldi	r25, 0x00	; 0
    79c6:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    79ca:	3e e1       	ldi	r19, 0x1E	; 30
    79cc:	30 93 e0 00 	sts	0x00E0, r19
    79d0:	07 c0       	rjmp	.+14     	; 0x79e0 <main+0x75e>
			bootLoader_SendChar(SIG_BYTE3);
			bootLoader_SendChar(SIG_BYTE2);
			bootLoader_SendChar(SIG_BYTE1);

		/* ESC */
		} else if(val != 0x1b) {
    79d2:	8b e1       	ldi	r24, 0x1B	; 27
    79d4:	f8 16       	cp	r15, r24
    79d6:	09 f4       	brne	.+2      	; 0x79da <main+0x758>
    79d8:	fa cc       	rjmp	.-1548   	; 0x73ce <main+0x14c>
void __vector_default(void) { ; }
#endif

static void bootLoader_SendChar(uint8_t data)
{
	uart_handle.transmit_char = data;
    79da:	9f e3       	ldi	r25, 0x3F	; 63
    79dc:	90 93 e0 00 	sts	0x00E0, r25
	HAL_comm_UART_Send(&uart_handle);
    79e0:	80 ee       	ldi	r24, 0xE0	; 224
    79e2:	90 e0       	ldi	r25, 0x00	; 0
    79e4:	0e 94 15 3d 	call	0x7a2a	; 0x7a2a <HAL_comm_UART_Send>
    79e8:	f2 cc       	rjmp	.-1564   	; 0x73ce <main+0x14c>

000079ea <HAL_comm_UART_Receive>:
	comm_UART_Send(HAL_transmitChar->transmit_char);
	return SUCCESS;
}

uint16_t HAL_comm_UART_Receive(void *receiveChar)
{
    79ea:	0f 93       	push	r16
    79ec:	1f 93       	push	r17
    79ee:	df 93       	push	r29
    79f0:	cf 93       	push	r28
    79f2:	00 d0       	rcall	.+0      	; 0x79f4 <HAL_comm_UART_Receive+0xa>
    79f4:	cd b7       	in	r28, 0x3d	; 61
    79f6:	de b7       	in	r29, 0x3e	; 62
    79f8:	8c 01       	movw	r16, r24
	
	uint16_t temp;
	if (comm_UART_Receive(&temp))
    79fa:	ce 01       	movw	r24, r28
    79fc:	01 96       	adiw	r24, 0x01	; 1
    79fe:	0e 94 27 3d 	call	0x7a4e	; 0x7a4e <comm_UART_Receive>
    7a02:	89 2b       	or	r24, r25
    7a04:	19 f0       	breq	.+6      	; 0x7a0c <HAL_comm_UART_Receive+0x22>
    7a06:	2f ef       	ldi	r18, 0xFF	; 255
    7a08:	3f ef       	ldi	r19, 0xFF	; 255
    7a0a:	07 c0       	rjmp	.+14     	; 0x7a1a <HAL_comm_UART_Receive+0x30>
	{
		return FAIL;
	}
	else
	{
		*(uint16_t*)receiveChar = temp;
    7a0c:	89 81       	ldd	r24, Y+1	; 0x01
    7a0e:	9a 81       	ldd	r25, Y+2	; 0x02
    7a10:	f8 01       	movw	r30, r16
    7a12:	91 83       	std	Z+1, r25	; 0x01
    7a14:	80 83       	st	Z, r24
    7a16:	20 e0       	ldi	r18, 0x00	; 0
    7a18:	30 e0       	ldi	r19, 0x00	; 0
		return SUCCESS;
	}	
    7a1a:	c9 01       	movw	r24, r18
    7a1c:	0f 90       	pop	r0
    7a1e:	0f 90       	pop	r0
    7a20:	cf 91       	pop	r28
    7a22:	df 91       	pop	r29
    7a24:	1f 91       	pop	r17
    7a26:	0f 91       	pop	r16
    7a28:	08 95       	ret

00007a2a <HAL_comm_UART_Send>:
	comm_UART_Initialize(HAL_uartInitConfig);
	return SUCCESS;
}

uint16_t HAL_comm_UART_Send(HAL_Comm_UART_HandleTypeDefStruct_t* HAL_transmitChar)
{
    7a2a:	fc 01       	movw	r30, r24
	comm_UART_Send(HAL_transmitChar->transmit_char);
    7a2c:	80 81       	ld	r24, Z
    7a2e:	0e 94 21 3d 	call	0x7a42	; 0x7a42 <comm_UART_Send>
	return SUCCESS;
}
    7a32:	80 e0       	ldi	r24, 0x00	; 0
    7a34:	90 e0       	ldi	r25, 0x00	; 0
    7a36:	08 95       	ret

00007a38 <HAL_comm_UART_Initialize>:
#include "USART.h"
#include "return_Errors.h"

uint16_t HAL_comm_UART_Initialize(HAL_Comm_UART_ConfigStruct_t* HAL_uartInitConfig)
{
	comm_UART_Initialize(HAL_uartInitConfig);
    7a38:	0e 94 5d 3d 	call	0x7aba	; 0x7aba <comm_UART_Initialize>
	return SUCCESS;
}
    7a3c:	80 e0       	ldi	r24, 0x00	; 0
    7a3e:	90 e0       	ldi	r25, 0x00	; 0
    7a40:	08 95       	ret

00007a42 <comm_UART_Send>:
/************************************************************************
* Put data into the UDR buffer to be sent                                                                  
************************************************************************/
uint16_t comm_UART_Send(unsigned char x)
{
	while (!(UCSRA_REG & UDR_ENABLE));	/*wait until the transmit buffer is empty and ready to be written*/
    7a42:	5d 9b       	sbis	0x0b, 5	; 11
    7a44:	fe cf       	rjmp	.-4      	; 0x7a42 <comm_UART_Send>
	UDR_REG = x;	/*put data into the buffer*/
    7a46:	8c b9       	out	0x0c, r24	; 12
	return SUCCESS;
}
    7a48:	80 e0       	ldi	r24, 0x00	; 0
    7a4a:	90 e0       	ldi	r25, 0x00	; 0
    7a4c:	08 95       	ret

00007a4e <comm_UART_Receive>:

/************************************************************************
* Return data found in the UDR buffer                                                                     
************************************************************************/
uint16_t comm_UART_Receive(void *receiveChar)
{
    7a4e:	fc 01       	movw	r30, r24
	uint16_t dataReg;
	
	while (!(UCSRA_REG & RXC_RECEIVE_COMPLETE));	/*wait until the receive is finished and the buffer is written*/
    7a50:	5f 9b       	sbis	0x0b, 7	; 11
    7a52:	fe cf       	rjmp	.-4      	; 0x7a50 <comm_UART_Receive+0x2>
	dataReg = UDR_REG;
    7a54:	8c b1       	in	r24, 0x0c	; 12
	*(uint16_t *) receiveChar = dataReg;
    7a56:	80 83       	st	Z, r24
    7a58:	11 82       	std	Z+1, r1	; 0x01
	return SUCCESS;
}
    7a5a:	80 e0       	ldi	r24, 0x00	; 0
    7a5c:	90 e0       	ldi	r25, 0x00	; 0
    7a5e:	08 95       	ret

00007a60 <__vector_13>:
/************************************************************************
* if interrupt happens (byte is received), write data in UDR_REG on port C, delay 0.1 sec,
* then send the same data again
************************************************************************/
 ISR(USART_RXC_vect)
{
    7a60:	1f 92       	push	r1
    7a62:	0f 92       	push	r0
    7a64:	0f b6       	in	r0, 0x3f	; 63
    7a66:	0f 92       	push	r0
    7a68:	11 24       	eor	r1, r1
    7a6a:	2f 93       	push	r18
    7a6c:	3f 93       	push	r19
    7a6e:	8f 93       	push	r24
    7a70:	9f 93       	push	r25
    7a72:	ef 93       	push	r30
    7a74:	ff 93       	push	r31
    7a76:	df 93       	push	r29
    7a78:	cf 93       	push	r28
    7a7a:	0f 92       	push	r0
    7a7c:	cd b7       	in	r28, 0x3d	; 61
    7a7e:	de b7       	in	r29, 0x3e	; 62
	volatile unsigned char value;
	value = UDR_REG;
    7a80:	8c b1       	in	r24, 0x0c	; 12
    7a82:	89 83       	std	Y+1, r24	; 0x01
    7a84:	88 ee       	ldi	r24, 0xE8	; 232
    7a86:	93 e0       	ldi	r25, 0x03	; 3
    7a88:	28 ec       	ldi	r18, 0xC8	; 200
    7a8a:	30 e0       	ldi	r19, 0x00	; 0
    7a8c:	f9 01       	movw	r30, r18
    7a8e:	31 97       	sbiw	r30, 0x01	; 1
    7a90:	f1 f7       	brne	.-4      	; 0x7a8e <__vector_13+0x2e>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7a92:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7a94:	d9 f7       	brne	.-10     	; 0x7a8c <__vector_13+0x2c>
	_delay_ms(100);
	comm_UART_Send(value);	/*just echo the data received*/
    7a96:	89 81       	ldd	r24, Y+1	; 0x01
/************************************************************************
* Put data into the UDR buffer to be sent                                                                  
************************************************************************/
uint16_t comm_UART_Send(unsigned char x)
{
	while (!(UCSRA_REG & UDR_ENABLE));	/*wait until the transmit buffer is empty and ready to be written*/
    7a98:	5d 9b       	sbis	0x0b, 5	; 11
    7a9a:	fe cf       	rjmp	.-4      	; 0x7a98 <__vector_13+0x38>
	UDR_REG = x;	/*put data into the buffer*/
    7a9c:	8c b9       	out	0x0c, r24	; 12
{
	volatile unsigned char value;
	value = UDR_REG;
	_delay_ms(100);
	comm_UART_Send(value);	/*just echo the data received*/
}
    7a9e:	0f 90       	pop	r0
    7aa0:	cf 91       	pop	r28
    7aa2:	df 91       	pop	r29
    7aa4:	ff 91       	pop	r31
    7aa6:	ef 91       	pop	r30
    7aa8:	9f 91       	pop	r25
    7aaa:	8f 91       	pop	r24
    7aac:	3f 91       	pop	r19
    7aae:	2f 91       	pop	r18
    7ab0:	0f 90       	pop	r0
    7ab2:	0f be       	out	0x3f, r0	; 63
    7ab4:	0f 90       	pop	r0
    7ab6:	1f 90       	pop	r1
    7ab8:	18 95       	reti

00007aba <comm_UART_Initialize>:
* Set the speed mode if Normal speed or Double speed.
*
* Enable interrupts                                                                    
************************************************************************/
uint16_t comm_UART_Initialize(HAL_Comm_UART_ConfigStruct_t* usart_init_config)
{
    7aba:	cf 93       	push	r28
    7abc:	df 93       	push	r29
    7abe:	ec 01       	movw	r28, r24
	uint16_t UBRR_VALUE;
	if(usart_init_config->U2X_State != 0)	/*if Double speed state is enabled*/
    7ac0:	88 85       	ldd	r24, Y+8	; 0x08
    7ac2:	28 81       	ld	r18, Y
    7ac4:	39 81       	ldd	r19, Y+1	; 0x01
    7ac6:	4a 81       	ldd	r20, Y+2	; 0x02
    7ac8:	5b 81       	ldd	r21, Y+3	; 0x03
    7aca:	88 23       	and	r24, r24
    7acc:	a9 f0       	breq	.+42     	; 0x7af8 <comm_UART_Initialize+0x3e>
	{
		UBRR_VALUE = (uint16_t)((F_CPU + usart_init_config->Baud*4UL)/(usart_init_config->Baud*8UL) - 1UL);
    7ace:	ca 01       	movw	r24, r20
    7ad0:	b9 01       	movw	r22, r18
    7ad2:	60 58       	subi	r22, 0x80	; 128
    7ad4:	7b 47       	sbci	r23, 0x7B	; 123
    7ad6:	81 4e       	sbci	r24, 0xE1	; 225
    7ad8:	9f 4f       	sbci	r25, 0xFF	; 255
    7ada:	b2 e0       	ldi	r27, 0x02	; 2
    7adc:	66 0f       	add	r22, r22
    7ade:	77 1f       	adc	r23, r23
    7ae0:	88 1f       	adc	r24, r24
    7ae2:	99 1f       	adc	r25, r25
    7ae4:	ba 95       	dec	r27
    7ae6:	d1 f7       	brne	.-12     	; 0x7adc <comm_UART_Initialize+0x22>
    7ae8:	a3 e0       	ldi	r26, 0x03	; 3
    7aea:	22 0f       	add	r18, r18
    7aec:	33 1f       	adc	r19, r19
    7aee:	44 1f       	adc	r20, r20
    7af0:	55 1f       	adc	r21, r21
    7af2:	aa 95       	dec	r26
    7af4:	d1 f7       	brne	.-12     	; 0x7aea <comm_UART_Initialize+0x30>
    7af6:	14 c0       	rjmp	.+40     	; 0x7b20 <comm_UART_Initialize+0x66>
	}
	else	/*if Normal speed state is enabled*/
	{
		UBRR_VALUE = (uint16_t)((F_CPU + usart_init_config->Baud*8UL)/(usart_init_config->Baud*16UL) - 1UL);
    7af8:	ca 01       	movw	r24, r20
    7afa:	b9 01       	movw	r22, r18
    7afc:	60 5c       	subi	r22, 0xC0	; 192
    7afe:	7d 4b       	sbci	r23, 0xBD	; 189
    7b00:	80 4f       	sbci	r24, 0xF0	; 240
    7b02:	9f 4f       	sbci	r25, 0xFF	; 255
    7b04:	f3 e0       	ldi	r31, 0x03	; 3
    7b06:	66 0f       	add	r22, r22
    7b08:	77 1f       	adc	r23, r23
    7b0a:	88 1f       	adc	r24, r24
    7b0c:	99 1f       	adc	r25, r25
    7b0e:	fa 95       	dec	r31
    7b10:	d1 f7       	brne	.-12     	; 0x7b06 <comm_UART_Initialize+0x4c>
    7b12:	e4 e0       	ldi	r30, 0x04	; 4
    7b14:	22 0f       	add	r18, r18
    7b16:	33 1f       	adc	r19, r19
    7b18:	44 1f       	adc	r20, r20
    7b1a:	55 1f       	adc	r21, r21
    7b1c:	ea 95       	dec	r30
    7b1e:	d1 f7       	brne	.-12     	; 0x7b14 <comm_UART_Initialize+0x5a>
    7b20:	0e 94 de 3d 	call	0x7bbc	; 0x7bbc <__udivmodsi4>
    7b24:	21 50       	subi	r18, 0x01	; 1
    7b26:	30 40       	sbci	r19, 0x00	; 0
	}

	UCSRC_REG = UBRR_SELECT;	/*URSEL is set to zero to update UBRRH*/
    7b28:	10 bc       	out	0x20, r1	; 32
	UBRRL_REG = UBRR_VALUE;	
    7b2a:	29 b9       	out	0x09, r18	; 9
	UBRRH_REG = UBRR_VALUE >> 8;
    7b2c:	30 bd       	out	0x20, r19	; 32
	
	comm_UART_Enable();
    7b2e:	0e 94 c1 3d 	call	0x7b82	; 0x7b82 <comm_UART_Enable>
	
	/*URSEL is set to one to update the UCSRC settings*/
	UCSRC_REG |= UCSRC_SELECT | usart_init_config->DataBits | usart_init_config->StopBits | usart_init_config->Parity;
    7b32:	80 b5       	in	r24, 0x20	; 32
    7b34:	9c 81       	ldd	r25, Y+4	; 0x04
    7b36:	89 2b       	or	r24, r25
    7b38:	80 68       	ori	r24, 0x80	; 128
    7b3a:	9d 81       	ldd	r25, Y+5	; 0x05
    7b3c:	89 2b       	or	r24, r25
    7b3e:	9e 81       	ldd	r25, Y+6	; 0x06
    7b40:	89 2b       	or	r24, r25
    7b42:	80 bd       	out	0x20, r24	; 32
	
	UCSRA_REG |= usart_init_config->U2X_State;
    7b44:	8b b1       	in	r24, 0x0b	; 11
    7b46:	98 85       	ldd	r25, Y+8	; 0x08
    7b48:	89 2b       	or	r24, r25
    7b4a:	8b b9       	out	0x0b, r24	; 11
	
	if(usart_init_config->EnableInterrupt)	/*if interrupt is enabled*/
    7b4c:	8f 81       	ldd	r24, Y+7	; 0x07
    7b4e:	88 23       	and	r24, r24
    7b50:	21 f0       	breq	.+8      	; 0x7b5a <comm_UART_Initialize+0xa0>
	{
		cli();
    7b52:	f8 94       	cli
		comm_UART_EnableInterruptRx();	/*enable receive interrupt*/
    7b54:	0e 94 da 3d 	call	0x7bb4	; 0x7bb4 <comm_UART_EnableInterruptRx>
		sei();
    7b58:	78 94       	sei
	}
	return SUCCESS;	
}
    7b5a:	80 e0       	ldi	r24, 0x00	; 0
    7b5c:	90 e0       	ldi	r25, 0x00	; 0
    7b5e:	df 91       	pop	r29
    7b60:	cf 91       	pop	r28
    7b62:	08 95       	ret

00007b64 <comm_UART_Disable>:
/************************************************************************
* disable UART receiver and transmitter
************************************************************************/
uint16_t comm_UART_Disable()
{
	UCSRB_REG &= (0<<RXEN) | (0<<TXEN);
    7b64:	8a b1       	in	r24, 0x0a	; 10
    7b66:	1a b8       	out	0x0a, r1	; 10
	return SUCCESS;
}
    7b68:	80 e0       	ldi	r24, 0x00	; 0
    7b6a:	90 e0       	ldi	r25, 0x00	; 0
    7b6c:	08 95       	ret

00007b6e <comm_UART_DisableRx>:
/************************************************************************
* disable UART receiver
************************************************************************/
uint16_t comm_UART_DisableRx()
{
	UCSRB_REG &= (0<<RXEN);
    7b6e:	8a b1       	in	r24, 0x0a	; 10
    7b70:	1a b8       	out	0x0a, r1	; 10
	return SUCCESS;
}
    7b72:	80 e0       	ldi	r24, 0x00	; 0
    7b74:	90 e0       	ldi	r25, 0x00	; 0
    7b76:	08 95       	ret

00007b78 <comm_UART_DisableTx>:
/************************************************************************
* disable UART transmitter
************************************************************************/
uint16_t comm_UART_DisableTx()
{
	UCSRB_REG &= (0<<TXEN);
    7b78:	8a b1       	in	r24, 0x0a	; 10
    7b7a:	1a b8       	out	0x0a, r1	; 10
	return SUCCESS;
}
    7b7c:	80 e0       	ldi	r24, 0x00	; 0
    7b7e:	90 e0       	ldi	r25, 0x00	; 0
    7b80:	08 95       	ret

00007b82 <comm_UART_Enable>:
/************************************************************************
* enable UART receiver and transmitter
************************************************************************/
uint16_t comm_UART_Enable()
{
	UCSRB_REG |= (1<<RXEN) | (1<<TXEN);
    7b82:	8a b1       	in	r24, 0x0a	; 10
    7b84:	88 61       	ori	r24, 0x18	; 24
    7b86:	8a b9       	out	0x0a, r24	; 10
	return SUCCESS;
}
    7b88:	80 e0       	ldi	r24, 0x00	; 0
    7b8a:	90 e0       	ldi	r25, 0x00	; 0
    7b8c:	08 95       	ret

00007b8e <comm_UART_EnableRx>:
/************************************************************************
* enable UART receiver
************************************************************************/
uint16_t comm_UART_EnableRx()
{
	UCSRB_REG |= (1<<RXEN);
    7b8e:	54 9a       	sbi	0x0a, 4	; 10
	return SUCCESS;
}
    7b90:	80 e0       	ldi	r24, 0x00	; 0
    7b92:	90 e0       	ldi	r25, 0x00	; 0
    7b94:	08 95       	ret

00007b96 <comm_UART_EnableTx>:
/************************************************************************
* enable UART transmitter
************************************************************************/
uint16_t comm_UART_EnableTx()
{
	UCSRB_REG |= (1<<TXEN);
    7b96:	53 9a       	sbi	0x0a, 3	; 10
	return SUCCESS;
}
    7b98:	80 e0       	ldi	r24, 0x00	; 0
    7b9a:	90 e0       	ldi	r25, 0x00	; 0
    7b9c:	08 95       	ret

00007b9e <comm_UART_DisableInterrupt>:
/************************************************************************
* disable UART interrupts
************************************************************************/
uint16_t comm_UART_DisableInterrupt()
{
	UCSRB_REG &= (0<<RXCIE) | (0<<TXCIE) | (0<<UDRIE);
    7b9e:	8a b1       	in	r24, 0x0a	; 10
    7ba0:	1a b8       	out	0x0a, r1	; 10
	return SUCCESS;
}
    7ba2:	80 e0       	ldi	r24, 0x00	; 0
    7ba4:	90 e0       	ldi	r25, 0x00	; 0
    7ba6:	08 95       	ret

00007ba8 <comm_UART_EnableInterrupt>:
/************************************************************************
* enable UART interrupts
************************************************************************/
uint16_t comm_UART_EnableInterrupt()
{
	UCSRB_REG |= (1<<RXCIE) | (1<<TXCIE) | (1<<UDRIE);
    7ba8:	8a b1       	in	r24, 0x0a	; 10
    7baa:	80 6e       	ori	r24, 0xE0	; 224
    7bac:	8a b9       	out	0x0a, r24	; 10
	return SUCCESS;
}
    7bae:	80 e0       	ldi	r24, 0x00	; 0
    7bb0:	90 e0       	ldi	r25, 0x00	; 0
    7bb2:	08 95       	ret

00007bb4 <comm_UART_EnableInterruptRx>:
/************************************************************************
* enable UART receive interrupts
************************************************************************/
uint16_t comm_UART_EnableInterruptRx()
{
	UCSRB_REG |= (1<<RXCIE);
    7bb4:	57 9a       	sbi	0x0a, 7	; 10
	return SUCCESS;
}
    7bb6:	80 e0       	ldi	r24, 0x00	; 0
    7bb8:	90 e0       	ldi	r25, 0x00	; 0
    7bba:	08 95       	ret

00007bbc <__udivmodsi4>:
    7bbc:	a1 e2       	ldi	r26, 0x21	; 33
    7bbe:	1a 2e       	mov	r1, r26
    7bc0:	aa 1b       	sub	r26, r26
    7bc2:	bb 1b       	sub	r27, r27
    7bc4:	fd 01       	movw	r30, r26
    7bc6:	0d c0       	rjmp	.+26     	; 0x7be2 <__udivmodsi4_ep>

00007bc8 <__udivmodsi4_loop>:
    7bc8:	aa 1f       	adc	r26, r26
    7bca:	bb 1f       	adc	r27, r27
    7bcc:	ee 1f       	adc	r30, r30
    7bce:	ff 1f       	adc	r31, r31
    7bd0:	a2 17       	cp	r26, r18
    7bd2:	b3 07       	cpc	r27, r19
    7bd4:	e4 07       	cpc	r30, r20
    7bd6:	f5 07       	cpc	r31, r21
    7bd8:	20 f0       	brcs	.+8      	; 0x7be2 <__udivmodsi4_ep>
    7bda:	a2 1b       	sub	r26, r18
    7bdc:	b3 0b       	sbc	r27, r19
    7bde:	e4 0b       	sbc	r30, r20
    7be0:	f5 0b       	sbc	r31, r21

00007be2 <__udivmodsi4_ep>:
    7be2:	66 1f       	adc	r22, r22
    7be4:	77 1f       	adc	r23, r23
    7be6:	88 1f       	adc	r24, r24
    7be8:	99 1f       	adc	r25, r25
    7bea:	1a 94       	dec	r1
    7bec:	69 f7       	brne	.-38     	; 0x7bc8 <__udivmodsi4_loop>
    7bee:	60 95       	com	r22
    7bf0:	70 95       	com	r23
    7bf2:	80 95       	com	r24
    7bf4:	90 95       	com	r25
    7bf6:	9b 01       	movw	r18, r22
    7bf8:	ac 01       	movw	r20, r24
    7bfa:	bd 01       	movw	r22, r26
    7bfc:	cf 01       	movw	r24, r30
    7bfe:	08 95       	ret

00007c00 <__eerd_byte_m32>:
    7c00:	e1 99       	sbic	0x1c, 1	; 28
    7c02:	fe cf       	rjmp	.-4      	; 0x7c00 <__eerd_byte_m32>
    7c04:	9f bb       	out	0x1f, r25	; 31
    7c06:	8e bb       	out	0x1e, r24	; 30
    7c08:	e0 9a       	sbi	0x1c, 0	; 28
    7c0a:	99 27       	eor	r25, r25
    7c0c:	8d b3       	in	r24, 0x1d	; 29
    7c0e:	08 95       	ret

00007c10 <__eewr_byte_m32>:
    7c10:	26 2f       	mov	r18, r22

00007c12 <__eewr_r18_m32>:
    7c12:	e1 99       	sbic	0x1c, 1	; 28
    7c14:	fe cf       	rjmp	.-4      	; 0x7c12 <__eewr_r18_m32>
    7c16:	9f bb       	out	0x1f, r25	; 31
    7c18:	8e bb       	out	0x1e, r24	; 30
    7c1a:	2d bb       	out	0x1d, r18	; 29
    7c1c:	0f b6       	in	r0, 0x3f	; 63
    7c1e:	f8 94       	cli
    7c20:	e2 9a       	sbi	0x1c, 2	; 28
    7c22:	e1 9a       	sbi	0x1c, 1	; 28
    7c24:	0f be       	out	0x3f, r0	; 63
    7c26:	01 96       	adiw	r24, 0x01	; 1
    7c28:	08 95       	ret

00007c2a <_exit>:
    7c2a:	f8 94       	cli

00007c2c <__stop_program>:
    7c2c:	ff cf       	rjmp	.-2      	; 0x7c2c <__stop_program>
